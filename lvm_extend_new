#!/bin/bash

#yucel ygemici justdoit @unix.com
######################## yucel gemici @ygemici unix.com ########################
######## Var olan bir LVM e yeni disk ekleme yada LVM icindeki disk e tanimlanan yeni size bilgisini LVM device a ekleme scripti ############
#### Yani VMWARE uzerinden verilen yeni diskin veya extend edilen disk alaninin LVM tarafina aktarilmasini saglar ####

##25-07-2023 # centos5 icin pvs ciktisi duzenlendi.
############ # pvs ciktisi default "G"(gigabyte) formatinda geliyor !!

#22-08-2023 # [new] parametresi gelistirildi..
#24-08-2023 # bazı düzeltme ve gelistirmeler yapıldı.. ( 1 GB (0.1 GB e kadar) altındaki alan extend ozelligi vs .. )

#04-12-2023 # [new] parametresi gelistirildi.. xfs/ext4 mkfs destegi..

#24-01-2025 # striped VG ler icin [ext] parametresi destegi eklendi..
#29-06-2025 # nvme disk extend desteği eklendi..

#08-11-2025 # striped VG ler icin [new] parametresi destegi eklendi..


printit() {
awk -v a="$1" 'BEGIN{$a=OFS="-";print $0;}';
}

help() {
printit 40
echo "Yucel Gemici - LV disk extend uygulamasi"
printit 40
echo "Ornek kullanim : ./$0 [sdxx] [VG] [ext] (s='size') "

# Bir disk bir VG e atanabildigine gore disk ismini(sdx) ogrenmek [vgextend] islemleri icin YETERLI olacaktir.
echo "Ornek kullanim : ./$0 [sdxx] [VG] [ext] "
echo "Ornek kullanim : ./$0 [sdxx] [VG] [new] "

# Bir VG icinde birden fazla LV device varsa extend edilecek LV device isminin elle girilmesi gerekecektir.
echo "Ornek kullanim : ./$0 [sdxx] [VG] [LV] [ext] "

# Yeni disk ekleme islemlerinde VG bilgisi zorunludur.
echo "Ornek kullanim : ./$0 [sdxx] [VG] [LV] [new] "

# new bilgisi verilmemise ilgili diskin zaten bir VG icinde oldugu ve bu VG icin size extend islemlerinin yapılacagi varsayilacaktir..
# new bilgisi verilmise ilgili diskin yeni bir disk oldugu ve ilgili VG icin extend islemlerinin yapılacagi varsayilacaktir..
# new bilgisi ile yeni bir LV device 'size' buyuklugunde olusturulabilir..

# not : sdb -> sdb2 gibi partition bilgileri duzenlemek icin "cloud-utils-growpart" icinde yer alan growpart uygulamasi kullanilmalidir"

# not : Sisteme yeni eklenilen bir diskin var olan bir VG icine eklenmesi asamasi 2 adimda yapilabilir :
# ./$0 [sdxx] [VG] [LV] [new] && ./$0 [sdxx] [VG] [LV] [ext]


### STRIPE new ###
# Stripe yapida bir [VG] olusturulmasi desteklenmez !!
# Cunku Stripe bir [VG] olusturulmasi asamasinda birden fazla parametre kullanilabilir.
# [ stripe disk count , stripe size ... ]

### exs ( 4 x stripes and a stripe size 128 KB )
# -> [pvcreate /dev/sda1 /dev/sdb1 /dev/sdc1 /dev/sdd1 ]
# -> [vgcreate vgdata /dev/sda1 /dev/sdb1 /dev/sdc1 /dev/sdd1 ]
# -> [lvcreate -l 100%FREE -i4 -I128 -n lvdata vgdata]
# -> [mkfs.xfs /dev/mapper/vgdata-lvdata] "
# https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/7/html/logical_volume_manager_administration/stripe_create_ex#stripe_create_ex

### STRIPE ext ###
# Var olan "lv_layout -> Stripe" set ise bu [VG] icin sadece extend islemleri yapilabilir ..
# Daha onceden Stripe [VG-striped] e dahil edilmis diskler extend edilemez ...
# ./$0 [sdb] [sdc] [sdd] [sde] [VG_striped] [ext]

# Stripe disk extend islemlerinde ayni sayida x disk bilgisi ( ör: "4" ) ve aktif bir [VG-striped] bilgisi zorunludur. !!
echo "Ornek kullanim : ./$0 [sdxx1] [sdxx2] [sdxx3] [sdxx4] [VG_striped] [[s]triped] [ext] "

echo "Ornek kullanim : ./$0 [sdxx1] [sdxx2] [sdxx3] [sdxx4] [VG_striped] [[s]triped] [new] "

printit 40
}

help;echo


errormsg() {
echo
echo "======HATA======"
exit 1
}

errchk() {
if [ $1 -ne 0 ] ; then
printit 40
echo "$2 islemi sirasinda HATA olustu !!! " ;
errormsg
fi
}


format_msg() {
for (( i=0;i<=5;i++))
do
#echo -en "\033[1A"
echo -en " [ $disk ] diski kullanilarak VG EXTEND edilecek. Emin degilseniz islemi [Ctrl-C] ile kesebilirsiniz !! \n"
sleep 0.4s;
echo -en "\033[1A"
echo -en "\033[2K"
#echo -en "
sleep 0.4s;
done
echo -en " [ $disk ] diski kullanilarak VG EXTEND edilecek. Emin degilseniz islemi [Ctrl-C] ile kesebilirsiniz !! \n"
echo
}







pvfscheck() {
pvcreteis=0
[ ! -z "$1" ] && [ $1 == "new" ] && pvcreteis=1 || pvcreteis=0
printit 30
echo "[$disk] diski bir [PV] diski olarak gorunmuyor.. !!"
echo "[$disk] disk bilgisi kullanilarak yeni bir [PV] diski olusturulacak ... "
sleep 2

fsx=$(file -sL "$devdisk"|awk -F'[:,;(]' '{print $2}'|awk -F";" '{print $1}')
case $fsx in
*boot*)echo "[$disk] diski ('boot sector') iceriyor.. [PV] diski olarak kullanilamaz !! " ; errormsg
;;
*no*read*|*cannot*|*error*)echo "[$disk] disk ('okuma/yazma') hatasi !! " ; errormsg
;;
*data*) echo "[$disk] diski uzerinde yeni bir [PV] diski olusturuluyor ... "
echo "[$disk] diski uzerindeki TUM VERILER KAYBOLACAK !!! "
sleep 3
echo -e "\n-> [pvcreate] islemini kesmek icin 'Ctrl-C' tuslarini kullanabilirsiniz !! "
printit 30
sleep 3
[ $pvcreteis -eq 1 ] && pvcreatex || echo "[pvcreate] islemleri [ext] mode da yapilamiyor !! "
echo
;;
*)echo "[$disk] diski uzerinde bir filesystem bilgisi olabilir !! "
;;
esac
}

pvccheck() {
pvc=$(pvs "$devdisk" 2>/dev/null)
}

pvscheck() {
## diskin PV diski oldugundan emin olunmasi gerekli !!
ispvs=0
###pvdisplay den VG bulma
vgdsk=$(pvdisplay "$devdisk" 2>/dev/null|awk '/VG Name/{print $3}')
###pvs den VG bulma
vgchkf=$(echo "$vgdsk"|awk 'END{print NR}')
if [ "$vgchkf" -ne 1 ] ; then
echo "[$disk] diski uzerinde birden fazla [VG] bulundu ??"
echo "LVM konfigurasyonunda yada uygulamada bir sorun olabilir !! "
sleep 2
errormsg
fi

if [ -z "$vgx" ] ; then
vgx="$vgdsk"
else

###vgx ilk kontrol !!! ###
##  Name contains invalid character, valid set includes: [a-zA-Z0-9.-_+].
vgx_chars=$(echo "$vgx" |grep -o .|grep -v -e '[a-z]' -e '[A-Z]' -e '[0-9]' -e '[-_+]' -e '\.')
if [[ ! -z "$vgx_chars" ]] ; then
echo "Girilen VG bilgisi [$vgx] gecersiz karakterler iceriyor gibi gorunuyor ->> " [ $vgx_chars ]
sleep 1
errormsg
fi
fi


#pvgc=$(pvs "$devdisk"|awk 'NR>1{if(NF==5)print "";else print $2}')
#pvc=$(pvs |grep "/$disk "|awk '{print $2}')

pvccheck;

case "$1" in

"new")
if [ -z "$pvc" ] ; then
sleep 1
pvfscheck "new"
else
echo "[$disk] diski zaten [PV] diski olarak gorunuyor .. [OK] "
printit 50


if [ -z "$vgdsk" ] ; then
echo "[$disk] diski icin tanimlanmis bir [VG] bilgisi bulunamadi !! "
echo "[$disk] diski icin [$vgx] bilgisi ile [vgcreate] yada [vgextend] islemi uygulanacaktir .. "
printit 50
sleep 2

else

if [ "$vgx" = "$vgdsk" ] ; then
ispvs=1
echo "->> [$disk] diski uzerinde [$vgx] isminde zaten bir [VG] mevcut !! "
echo "Bu durumda [$vgx] [VG] kullanilarak YENI bir [LV] olusturulacak ... "
echo
sleep 1
else
pvlayout=$(pvs -o+lv_layout,stripes|awk -v a="$vgdsk" 'a==$2{print $(NF-1);exit}')
echo "-> [$disk] diski uzerinde [$vgdsk] isminde *[VG-${pvlayout}] yapida zaten bir [VG] mevcut !! "
#echo "[$disk] diski uzerinde [$vgx] isminde YENI bir [VG] olusturulacak ... "
echo "-> Ayni disk uzerinde birden fazla [VG] olusturulamaz. [FAIL] "
sleep 2
errormsg
fi

fi

fi
;;


"ext")
if [ -z "$pvc" ] ; then
pvfscheck
printit 30
[[ $ispvalready -ne 1 ]] && echo "[./$0 $disk VG (LV) new] komutu ile yeni bir [PV] olusturabilirsiniz.. "
errormsg
fi

vgdskn=$(pvdisplay "$devdisk" 2>/dev/null|awk '/VG Name/{print $3}')
if [ "$vgdskn" != "$vgx" ] ; then
if [ -b "$vgx" ] ; then
echo "[VG] bilgisi icin girilen deger [$vgx] bir disk device olarak gorunuyor !! "
errormsg
else
if [ -b "/dev/$vgx" ] ; then
echo "[VG] bilgisi icin girilen deger [$vgx] bir disk device olarak gorunuyor !! "
errormsg
fi
fi

echo "[$disk] diski uzerinde [$vgx] isminde bir [VG] bilgisi bulunamadi !!! "
sleep 1
vguess "$devdisk"
fi


if [ "$vgdskn" != "$vgx" ] ; then
echo
echo "[$disk] diski uzerinde [$vgx] isminde bir [VG] bilgisi bulunamadi !!!! "
errormsg
fi
;;

esac
}


vgscheck() {
vgc="$1"
if [[ -b "/dev/$vgc" ]] ; then
echo "[VG] olarak verilen parametre [$vgc] degeri sistem uzerinde bir disk device olarak gorunuyor .. !! [FAIL] "
errormsg
fi

case "$2" in
#"ext") if [ ! -z "$vgc" ] ; then
#echo "[$disk] zaten bir VG [$vgc] icinde gorunuyor !! "
#echo "[$disk] diski icin size extend islemi uygulanmak isteniyorsa [new] parametresi kullanMAdan uygulamayi calistirabilirsiniz.. !! "
#errormsg
#fi
"new") vgcc=$1
isanothervg=$(pvs|awk -v a=$vgcc '$2==a{print $1}'|grep -v $devdisk)
if [ ! -z "$isanothervg" ] ; then
isanothervgc=$(echo "$isanothervg"|awk 'END{print NR}')
[[ $isanothervgc -gt 1 ]] && mess1="diskler" || mess1="disk"
echo "[$vgcc] isimli [VG] zaten asagidaki $mess1 uzerinde tanimli gorunuyor !! "
printit 40
echo "$isanothervg"
printit 40
sleep 3
fi
;;
esac
}


sizetogib() {
sizecx=$1 ##kaynak : [kmgt]b
sizex=$2 ##hedef : [KMGT]B

case "$sizecx" in
*T)sizegib=$(awk -v a="$sizex" 'BEGIN{s=(a*1000000000000)/1099511627776;printf "%.9f",s}')
;;
*G)sizegib=$(awk -v a="$sizex" 'BEGIN{s=(a*1000000000)/1073741824;printf "%0.9f",s}')
;;
*M)sizegib=$(awk -v a="$sizex" 'BEGIN{s=(a*1000000)/1048576;printf "%0.9f",s}')
;;
*K)sizegib=$(awk -v a="$sizex" 'BEGIN{s=(a*1000)/1024;printf "%0.9f",s}')
;;
*B)sizegib=$(awk -v a="$sizex" 'BEGIN{s=a;print s}')
;;
*)echo "Size unit convert islemleri sirasinda HATA olustu !! "
errormsg
;;
esac

if [ ! -z "$sizegib" ] ; then
unitx=$(echo $sizecx|sed "s/$sizex//")
unitxl=$(echo $unitx|awk '{print tolower($0)}')
newsizec=${sizegib}$unitxl
newsizeshow=$(awk -v a="$sizegib" 'BEGIN{printf "%0.2f",a}')
newsizeshowunit=$(echo ${newsizeshow}$unitxl)
#sizec=$newsizec
sleep 1
else
echo "Size bilgisi Gib cevirme sirasinda bir hata olustu !! "
errormsg
fi
}


sizeprmchk() {
## 's=100g' vb. size bilgisi sadece SON parametrede  aranir !!
echo "$1"|grep "s=[0-9]*[\.]*[0-9]\+" &>/dev/null
if [ $? -eq 0 ] ; then
sizec=$(echo "$1"|sed 's/s=//')

echo "$sizec"|grep -i '[0-9]\+[bkmgt]$' &>/dev/null
if [ $? -ne 0 ] ; then
echo "size bilgisi B(b)/K(k)/M(m)/G(g)/T(t) cinsinden belirtilmeli.. !! "
errormsg
fi

else

for i in $2 ; do
echo "$i"|grep "^s=" &>/dev/null
#echo "$i"|grep "s=[0-9]\+" &>/dev/null
if [ $? -eq 0 ] ; then

echo "$i"|grep -i '^s=[0-9]\+[bkmgt]$' &>/dev/null
if [ $? -ne 0 ] ; then sizemsg="s=xxx[BKMGT]" ; else sizemsg="$i" ; fi

echo "size bilgisi belirtilmek istenildigi durumlarda '$sizemsg' formatinda (ve SON parametre olarak ) belirtilmelidir !! "
echo
errormsg
fi
done
fi

#[ ! -z "$sizec" ] && size=$(echo "$sizec"|sed 's/[^0-9]\+//' ) || size=""
[ ! -z "$sizec" ] && size=$(echo "$sizec"|sed 's/.$//') || size=""
if [ ! -z "$size" ] ; then
unit=$(echo $sizec|sed "s/$size//")
case "$unit" in
B|K|M|G|T)sizetogib $sizec $size
echo "-> Istenilen Size bilgisi [$newsizeshowunit] olarak hesaplandi [OK] "
sizec=$newsizeshowunit
;;
b|k|m|g|t)
echo "-> Istenilen Size bilgisi [$sizec] olarak hesaplandi .. "
#echo "Size unit bilgileri 1024 un katlari olarak kabul ediliyor .. [Kibibyte=k,Mebibiyte=m,Gigibyte=g,Tebibyte=t] "
sleep 1
;;
*)echo "Size 'unit' bilgisi hatali !! "
errormsg
esac
printit 30
####free_size ile girilen size bilgisi karsiirmak icin gerekli.
sizesaved=$sizec
#else
#echo "Size bilgisi islemlerinde bir sorun olustu !! "
#errormsg
fi
}


pvresizemsg() {
echo
printit 50
echo "[$disk] diski icin [pvresize] komutu uygulaniyor ..."
printit 50
sleep 1
echo
}


growpart_ex_menu() {
echo "growpart /dev/sdb 1"
echo "CHANGED: partition=1 start=2048 old: size=419428352 end=419430400 new: size=2147481567 end=2147483615"
}


###lsblk onemli
lsblkchk() {
((lsblkc++))
which lsblk &>/dev/null
if [ $? -ne 0 ] ; then
if [ $lsblkc -eq 1 ] ; then
printit 30
echo "Sunucuda [lsblk] bulunamadi !! "
printit 30
fi
lsblkok=0
else
lsblkok=1
fi
}


partedchk() {
((partedc++))
which parted &>/dev/null
##ubuntu da "-s" parametresi sorun cikariyor.
#which parted -s &>/dev/null
if [ $? -ne 0 ] ; then
if [ $partedc -eq 1 ] ; then
printit 30
echo "Sunucuda [parted] bulunamadi !! "
printit 30
fi
partedok=0
else
partedok=1
fi
}



parted_free_pre() {
dsk=$1
#GiB cinsinden
#rawsize_p=$(parted -s $dsk unit Gib print 2>/dev/null|awk '/Disk/{print $NF;exit}')
rawsize_p=$(parted -s $dsk unit b print 2>/dev/null|awk '/Disk/{printf "%.2f",$NF/1073741824;exit}')
#rawsize_f=$(echo "$rawsize_p"|sed 's/[^0-9\.]//g')
if [ ! -z $rawsize_p ] ; then
rawsize_f=$rawsize_p
else
[ $lsblkok -eq 1 ] && lsblk_free_pre $dsk
fi
[ -z $rawsize_p ] && echo "[$dsk] icin size bilgisi bulunamadi !! "
}


lsblk_free_pre() {
dsk=$1
#GiB cinsinden
rawsize_p=$(lsblk -b $dsk |awk '/ 8:/{print $4/1073741824}'|awk 'NR==1{x=$1}NR>1{px+=$1}END{printf "%.2f",(x-px)}')
#rawsize_f=$(echo "$rawsize_p"|sed 's/[^0-9\.]//g')
if [ ! -z $rawsize_p ] ; then
rawsize_f=$rawsize_p
else
echo "[$dsk] icin size bilgisi bulunamadi !! "
[ $partedok -eq 1 ] && parted_free_pre $dsk
fi
[ -z $rawsize_p ] && echo "[$dsk] icin size bilgisi bulunamadi !! "
}


partsizechk_pre() {
partedchk;lsblkchk;
diskf=$1
if [ $partedok -eq 1 ] ; then
###parted free alan kontrolu
parted_free_pre $diskf
else
###lsblk free alan kontrolu
if [ $lsblkok -eq 1 ] ; then
lsblk_free_pre $diskf
else
echo "parted veya lsblk uygulamalari olmadan islem YAPILAMAZ !! "
echo
printit 30
errormsg
fi
fi
[ -z "$rawsize_f" ] && rawsize_f=0
}


pvalignmentchk() {
diskx="$1"
dataalig=$(pvs -o +pe_start $diskx|awk 'NR>1{print $NF}')

case $dataalig in
*B|*b)pvdataaligib=$(awk -v a="$dataalig" 'BEGIN{s=a/1024/1024/1024;print s}')
;;
*K|*k)pvdataaligib=$(awk -v a="$dataalig" 'BEGIN{s=a/1024/1024;print s}')
;;
*M|*m)pvdataaligib=$(awk -v a="$dataalig" 'BEGIN{s=a/1024;print s}')
;;
*G|*g)pvdataaligib=$(awk -v a="$dataalig" 'BEGIN{s=a/1;print s}')
;;
*T|*t)pvdataaligib=$(awk -v a="$dataalig" 'BEGIN{s=a*1024;print s}')
;;
*)echo "[PV] alignment bilgisi hesaplanirken tanimsiz unit bilgisi tespit edildi !! "
errormsg
;;
esac
}


partsizechk_cal()
{
presize="$1"
aftsize="$2"
#iptal -> pesize(4 Mib ) 0.00390625 GiB(0.004194304 GB) ( min kabul edilecek alan miktari )
pvalignmentchk $devdisk
freeszgibx=$(awk -v a="$presize" -v b="$aftsize" -v c="$pvdataaligib" 'BEGIN{s=b-a;if(s>c)printf "%.2f", s}')
freeszgbx=$(awk -v a="$freeszgibx" 'BEGIN{printf "%.2f" , (a*1073741824)/1000000000}')
freeszgib=$(echo "$freeszgibx"|sed 's/\.00$//')
freeszgb=$(echo "$freeszgbx"|sed 's/\.00$//')
}


growpartmsg() {
if [ $growpartprint -ne 1 ] ; then
freerawgib=$1
diskprt=$(echo "$disk"|sed 's/[^0-9]*//g')
[[ "$diskother" = "ok" ]] && diskprt=$(echo "$disk"|sed 's/.*p\([0-9]*\)$/\1/')
echo
printit 70
if [[ $freeraw_new -eq 1 ]] ; then
[[ $freeraw_old -eq 1 ]] && FREE_RAW="Yeni ve Mevcut" || FREE_RAW="Yeni"
else
[[ $freeraw_old -eq 1 ]] && FREE_RAW="Mevcut"
fi
[[ -z "$FREE_RAW" ]] && FREE_RAW="Mevcut"
[[ ! -z "$diskdevx" ]] && grow_devdisk="$diskdevx" || grow_devdisk="$devdisk"
[[ ! -z "$freerawgib" ]] && \
echo "[ growpart $grow_devdisk $diskprt ] komutu ile bu ( $freerawgib Gib ) $FREE_RAW RAW alani [$disk] partitiona aktarmayi deneyebilirsiniz .. " || \
echo "[ growpart $grow_devdisk $diskprt ] komutu ile bu $FREE_RAW RAW alani [$disk] partitiona aktarmayi deneyebilirsiniz .. "
echo "[ growpart shell script ] dosyasi [ cloud-utils-growpart ] paketi icinde yer almaktadir !! "
#growpart_menu
printit 70
growpartprint=1
fi
}


lsblk_parted_free() {
diskf=$1
#freesz=$(lsblk "$diskf"|awk 'NR==1{sub("G","",$4);x=$4}NR>1{sub("G","",$4);px+=$4}END{if((x-px)>1)print x-px}' )
#freeszgib=$(lsblk -b -o KNAME,TYPE,SIZE |grep $diskf|awk 'BEGIN{OFS="\t"} {print $1,$2,$3/1073741824"G"}'|awk 'NR==1{sub("G","",$3);x=$3}NR>1{sub("G","",$3);px+=$3}END{if((x-px)>1)print x-px}')
#freeszgb=$(lsblk -b -o KNAME,TYPE,SIZE $diskf|awk 'BEGIN{OFS="\t"} {print $1,$2,$3/1000000000}'|awk 'NR==1{sub("G","",$3);x=$3}NR>1{sub("G","",$3);px+=$3}END{if((x-px)>1)print x-px}')

### "8:" scsi disks
#rawsize=$(lsblk -b $diskf |awk '/ 8:/{print $4/1000000000}'|awk 'NR==1{x=$1}NR>1{px+=$1}END{printf "%0.4s%s\n",(x-px),"GB"}')


### Eger disk partition degilse
###############################

#disk size after scsi scan
partsizechk_pre $diskf
rawsize=$rawsize_f


if [ ! -z "$rawsize" ] && [ ! -z "$rawsizef" ] ; then
partsizechk_cal "$rawsizef" "$rawsize"
else
echo "RAW size bilgileri elde edilirken bir sorun olustu !! "
echo
errormsg
fi


################
###RAW space
################

growpartprint=0
freeraw_old=0

freeszchkgib=$(awk -v a="$freeszgib" 'BEGIN{if(a>=1024)printf "%0.2f",a/1024}')
freeszchkgb=$(awk -v a="$freeszgb" 'BEGIN{if(a>=1024)printf "%0.2f",a/1024}')

if [ ! -z "$freeszgib" ] ; then
freeraw_new=1

[ ! -z "$freeszchkgib" ] && echo "[$diskchk] diskinde [ $freeszchkgib Tib ( $freeszchkgb TB ) ] kadar YENI bir (Free RAW) alan bulundu .. " || echo "[$diskchk] diskinde [ $freeszgib Gib ( $freeszgb GB ) ] kadar YENI bir (Free RAW) alan bulundu .. "
sleep 2

echo
printit 30
echo "Kernel taramasindan sonra DISK bilgisi ... "
printit 30
sleep 1

if [ $lsblkok -eq 1 ] ; then
lsblk $diskf
else
if [ $parted -eq 1 ] ; then
#parted -s $diskf print #|awk '/Number/{while(getline)if($1~/^[0-9]$/)print $1}'
parted -s $diskf unit Gib print free 2>/dev/null|awk '/Number/{print;while(getline)print}'
printit 30
fi
fi

sleep 1

#### Free RAW alan bulunmasa bile Free LV alan olabilir. Bundan dolayi islemlere devam edilir..

else
freeraw_new=0

## Eger PV disk tum (whole) disk ( or : sda ) ise partition yapisi olmadigi icin MEVCUT aktarim dan bahsedilemez ?

printit 50

[[ "$diskother" = "ok" ]] && diskchk=$diskdx && diskdev=$diskdx

echo "[$diskchk] diski icin YENI bir (Free RAW) alan bulunamadi !!"
printit 50
sleep 2
echo

fi

### Eger PV disk , partition device ise MEVCUT(daha onceden eklenmis ama kullanilmamis ) kullanilabilir Free RAW alan aranir..
#if [ "$isdisk" = "part" ] ; then
diskdevx="$devdisk"


printit 50
echo "[$disk] diski icin daha onceden eklenmis MEVCUT (Free RAW) alan kontrolu yapiliyor .. "
printit 50
sleep 1

###->>>> Disk ile partition size arasinda fark ###
partsizechk_pre $diskdevx
rawsize2=$rawsize_f
partsizechk_pre $devdisk
partsizechk_cal "$rawsize_f" "$rawsize2"

freeszchkgib=$(awk -v a="$freeszgib" 'BEGIN{if(a>=1024)printf "%0.2f",a/1024}')
freeszchkgb=$(awk -v a="$freeszgb" 'BEGIN{if(a>=1024)printf "%0.2f",a/1024}')

if [ ! -z "$freeszgib" ] ; then
[ ! -z "$freeszchkgib" ] && echo "[$diskdev] diski ile [$disk] arasinda [ $freeszchkgib Tib ( $freeszchkgb TB ) ] buyuklugunde bir FARK tespit edildi .. " || echo "[$diskdev] diski ile [$disk] arasinda [ $freeszgib Gib ( $freeszgb GB ) ] buyuklugunde bir FARK tespit edildi .. "
echo "->> Bu alanin [$disk] icin kullanilabilir olup olmadigini kontrol edin ... "
growpartmsg "$freeszgib"
sleep 1
free_othersgib=$(lsblk -b $diskdevx|grep "$diskdev"|grep -v "$diskdev "|grep -v "$disk "|awk '{x+=$4}END{printf "%.2f",x/1073741824}')
free_remaingib=$(awk -v a="$free_othersgib" -v b="$freeszgib" 'BEGIN{if(b>a)print b-a}' )

if [ -z "$free_remaingib" ] ; then
echo "->> Dikkat : Bu alanin [$free_othersgib Gib] bir kismi farkli partitionlar tarafindan kullaniliyor olabilir ... "
else
freeraw_old=1
fi


sleep 2
printit 50

echo
echo "Free RAW alan kontrolu "
printit 40

if [ $partedok -eq 1 ] ; then
echo "== parted == "
printit 20
#parted -s $diskdevx unit Gib print free 2>/dev/null|awk '/Number/{print;while(getline)print}'
parted -s $diskdevx unit Gib print free 2>/dev/null|awk '/Number/{print;while(getline)if(/Free/)print $0 "\t\t\t\t\t" "->> [FREE] " ; else print}'
printit 20
echo
sleep 2

##1 GB dan kucuk Free alanlar goz ardi edilir
freeforgibp=$(parted -s $diskdevx unit B print free 2>/dev/null|awk '/Free/{x=$3;if(x>1073741824)sx+=x}END{printf "%0.2f",sx/1073741824}')
freerawgibp=$(awk -v a="$freeforgibp" 'BEGIN{if(a>1)print "OK"}')

fi

if [ $lsblkok -eq 1 ] ; then
#lsblk $diskdevx|head -1 ; lsblk $diskdevx|grep "$diskdev"|sed "s/$disk .*\|$diskdev .*/& \t\t <- /"
printit 20
echo "== lsblk == "
printit 20
lsblk $diskdevx|head -1 ; lsblk $diskdevx|grep $diskdev|sed -e '1!s/^..//g' -e '1s/^\([^ ]*\)  \(.*\)/\1\2/'|awk -v a="$disk" -v b="$diskdev" '$1!=a && $1!=b{x++;gsub(" ","",$NF); printf "%-60s %s%s%s\n",$0,"->> [diger_part_",x,"]";next}1'
printit 20
#lsblk $diskdevx|grep "$disk"
echo
sleep 2

##1 GB dan kucuk Free alanlar goz ardi edilir
freeforgibl=$(lsblk -b $diskdevx|awk '/ 8:/{if(NR==2)s=$4;else sx+=$4}END{x=s-sx;if(x>1073741824)printf "%0.2f",x/1073741824}')
##diskother -> nvme MAJOR -> 259
[[ "$diskother" = "ok" ]] && freeforgibl=$(lsblk -b $diskdevx|awk '/ 259:/{if(NR==2)s=$4;else sx+=$4}END{x=s-sx;if(x>1073741824)printf "%0.2f",x/1073741824}')
freerawgibl=$(awk -v a="$isfreeforgibl" 'BEGIN{if(a>1)print "OK"}')

fi

[ ! -z "$freerawgibp" ] && growpartmsg "$freeforgibp"
[ ! -z "$freerawgibl" ] && growpartmsg "$freeforgibl"

else
echo "[$disk] diski icin MEVCUT bir (Free RAW) alan bulunamadi !!"
echo
fi



#### PV disk - RAW disk farki ####
pvsize_cal
partsizechk_pre $devdisk
rawsizef=$rawsize_f
partsizechk_cal "$sizepv" "$rawsizef"


if [ ! -z "$freeszgib" ] ; then
echo
printit 50
echo "[$disk] diski ile [PV] [$disk] arasinda [ $freeszgib Gib ( $freeszgb GB ) ] buyuklugunde bir (Free RAW) alan oldugu tespit edildi .. "

###Sadece 1 Gib ve uzerindeki buyuklukler dikkate alinir..
sizedif1=$(awk -v a="$freeszgib" 'BEGIN{if(a>=1)print "OK"}')
[ ! -z "$sizedif1" ] && freeraw_pvs=1 || freeraw_pvs=0

else

printit 50
echo "[$disk] diski ile [PV] [$disk] arasinda MEVCUT bir (Free RAW) alan bulunamadi !!"
freeraw_pvs=0

##0.1Gib ve altindaki degerler PV aligment icin kullaniliyor olabilir !! ??
sizedif2=$(awk -v a="$freeszgib" 'BEGIN{if(a<=0.1)print "OK"}')
if [ ! -z "$sizedif2" ] ; then
echo "[$disk] diski ( -> $rawsizef Gib ) alani ile [PV] disk ( -> $sizepv Gib ) alani esit gorunuyor .. "
sleep 1
fi

fi
}


####iptal
parted_free() {
diskf=$1
###parted -s free alan kontrolu
#freesz=$(parted -s "$diskf" unit GB print free|awk '/Free/{sub("GB","",$3);if($3>1){print $3;exit}}' )
#freesz=$(parted -s "$diskf" unit GB print free 2>/dev/null|awk '/Free/{sub("GB","",$3);if($3>1)x+=$3;}END{if(x>1)print x}')

#rawsize=$(parted -s $diskf unit GB print|awk '/Disk/{print $NF;exit}')
partsizechk_pre $diskf
rawsize=$rawsize_f

[ ! -z "$rawsize" ] && partsizechk_cal "$rawsize_f" "$rawsize"
if [ ! -z "$freeszgib" ] ; then

freeszchkgib=$(awk -v a="$freeszgib" 'BEGIN{if(a>=1024)printf "%0.2f",a/1024}')
freeszchkgb=$(awk -v a="$freeszgb" 'BEGIN{if(a>=1024)printf "%0.2f",a/1024}')

[ ! -z "$freeszchkgib" ] && echo "[$diskf] diskinde [ $freeszchkgib Tib ( $freeszchkgb TB ) ] lik bir (Free RAW) alan bulunuyor.." || echo "[$diskf] diskinde [ $freeszgib Gib ( $freeszgb GB ) ] lik bir (Free RAW) alan bulunuyor.."

diskprt=$(echo "$disk"|sed 's/[^0-9]//g')
[[ "$diskother" = "ok" ]] && diskprt=$(echo "$disk"|sed 's/.*p\([0-9]*\)$/\1/')

printit 30
echo "'growpart $devdisk $diskprt' komutu ile bu Free alani [$disk] partitiona aktarip bu alani da kullanabilirsiniz .. "
echo "'growpart shell script i 'cloud-utils-growpart' paketi icinde yer almaktadir !! "
#growpart_menu
#printit 50
else
printit 50
echo "[$disk] icin (Free RAW) alan bulunamadi !!"
printit 50
echo
fi
}


partsizechk() {
partedchk;
partdisk="$1"
###parted free alan kontrolu
if [ $partedok -eq 1 ] || [ $lsblkok -eq 1 ] ; then
lsblk_parted_free "$partdisk"
else
echo "parted veya lsblk uygulamalari olmadan islem YAPILAMAZ !! "
echo
fi
}


diskpartscan() {
diskd="$1"

##scsi
echo "$diskd"|grep '^sd' &>/dev/null
if [ $? -eq 0 ] ; then
diskchk=$(echo "$diskd"|grep 'sd'|sed 's/[0-9]*$//')
fi


#mpath(friendly_names) mapper_to_dm
echo "$devdisk"|grep 'mapper'|grep -v 'mpath' &>/dev/null
if [ $? -eq 0 ] ; then
diskchk=$(ls -ltr "$devdisk"|sed 's/.*mapper.* .*\/\(.*\)/\1/')
disk=$diskchk
fi

##mpath
#echo "$diskd"|egrep '^dm-|^mpath*' &>/dev/null
#echo "$devdisk"|egrep 'mapper' &>/dev/null
echo "$devdisk"|grep -e '/dev/mapper/' -e '/dev/dm-' >/dev/null
if [ $? -eq 0 ] ; then
mpathx=$(ls -ltr /dev/mapper/|grep " $diskd "|sed 's/.*\(dm-.*\)/\1/')
diskchk="$mpathx"
fi


[[ "$diskother" = "ok" ]] && diskchk="$diskdx"

[ -z "$diskchk" ] && diskchk="$diskd"
echo "[$diskchk] icin KERNEL seviyesinde YENI (Free RAW) alanlari icin tarama yapiliyor ... "
echo "...."
sleep 1
echo "....."
sleep 1
echo "......"
}


partscan() {
diskscan="$1"
partsizechk_pre $diskscan
rawsizef=$rawsize_f
}


multipath_new() {
mpaths=$(multipath -l "$1"|sed -n '/:/{s/.*[^ ]*:[^ ]*:[^ ]*:[^ ]* \([^ ]*\) .*/\1/p}')
#multipathd -k'resize map '$disk''
multipathd resize map "$1"
sleep 1
printit 30
for i in $mpaths; do
echo "$i re-scanning .. " 
echo 1 > /sys/block/$i/device/rescan
done
printit 30
sleep 1
systemctl restart multipathd
#dmsetup reload map
#systemctl reload multipathd
sleep 1
partsizechk "$2" 
}


diskpartchk() {
mpath=0
[[ "$diskother" = "ok" ]] && diskpartscan "$diskdx" || diskpartscan "$disk"
if [ "$diskother" = "ok" ] ; then
partscan "$devdisk"

###############
echo 1 > /sys/block/$diskdx/device/rescan
partsizechk "$devdisk"

else


#mpath
#echo "$disk"|grep '^mpath*' &>/dev/null
echo "$devdisk"|grep -e '/dev/mapper/' -e '/dev/dm-' &>/dev/null
if [ $? -eq 0 ] ; then
mpath=1

#mpath part check
if [[ $lsblkok -eq 1 ]] ; then 
part_check=$(lsblk -o NAME,TYPE -n -i -r "$devdisk" 2>/dev/null|awk 'NR==1'|grep part)
[[ -z "$part_check" ]] && partscan "$devdisk" && isdisk=disk && mpathdsk=disk
else
which partprobe &>/dev/null
if [ $? -eq 0 ] ; then
part_check2=$(partprobe -d -s "$devdisk" 2>/dev/null)
[[ ! -z "$part_check2" ]] && partscan "$devdisk" && isdisk=disk && mpathdsk=disk
else
echo "lsblk veya partprobe olmadan isleme devam edilemiyor !! "
errormsg
fi
fi

if [[ "$mpathdsk" = "disk" ]] ; then
##mpath disk
echo "$devdisk"|grep -e '/dev/mapper/' &>/dev/null
if [ $? -eq 0 ] ; then
dm_disk=$(ls -ltr "$devdisk"|sed 's;.*../\([^ ]*\);\1;')
dm_disk_dev=$(echo "/dev/$dm_disk")
multipath_new "$dm_disk_dev" "$devdisk"
fi

echo "$devdisk"|grep '/dev/dm-' &>/dev/null
if [ $? -eq 0 ] ; then
partscan "$devdisk"
multipath_new "$devdisk" "$devdisk"
fi


##mpath part
else
##mpath part
isdisk=part

echo "$devdisk"|grep '/dev/dm-' &>/dev/null
if [ $? -eq 0 ] ; then
dm_part_id=$(echo "$disk"|sed 's;dm-;;')
dm_disk_id=$(dmsetup ls --tree|grep -A1 ":$dm_part_id"\)|awk 'END{print}'|sed 's;.*:\([^ ]\)*);\1;')
diskdev=$(echo "/dev/dm-$dm_disk_id")
partscan "$devdisk"
multipath_new "$diskdev" "$devdisk"
else
#mpath
diskdev=$(echo "$disk"|sed 's/[0-9]\+//g')
partscan "$devdisk"
multipath_new "$diskdev" "$devdisk"
fi

fi

fi


###not mpath
if [[ $mpath -ne 1 ]] ; then
echo "$disk"|grep '[0-9]$' &>/dev/null
if [ $? -eq 0 ] ; then

##partition
diskdev=$(echo "$disk"|sed 's/[0-9]\+//g')
partscan "$devdisk"
isdisk=part

###############
echo 1 > /sys/block/$diskdev/device/rescan
partsizechk "/dev/$diskdev"
###############

else
### disk size before scsi scan
partscan "$devdisk"
isdisk=disk

###############
echo 1 > /sys/block/$disk/device/rescan
partsizechk "$devdisk"
###############

fi
fi

#partprobe $devdisk
##eger disk yerine partition bilgisi kullaniliyorsa free space in daha onceden bu partitiona aktarildigina EMIN olunmasi gerekiyor..
fi
}


lvsizemib() {
#sizelvmib=$(awk -v a="$sizexx" 'BEGIN{print a*1024}')
sizelvmib=$(lvs|awk -v a="$lvx" 'a==$1'|awk '$NF=="0"{exit}$NF~/</{sub("<","",$NF)}$NF~/t|T/{x=$NF*1048576}$NF~/g|G/{x=$NF*1024;}$NF~/k|K/{x=$NF/1024;}$NF~/m|M/{x=$NF/1;}{printf "%0.9f",x}')
#sizelvmibok=$(lvs|grep "$lvx "|awk '$NF~/</{sub("<","",$NF)}$NF~/m|M|k|K/{print "OK"}')
sizelvmibshow=$(awk -v a="$sizelvmib" 'BEGIN{printf "%0.2f",a}')
}

lvsizegib() {
sizelvgib=$(lvs|awk -v a="$lvx" 'a==$1'|awk '$NF=="0"{exit}$NF~/</{sub("<","",$NF)}$NF~/k|K/{x=$NF/1048576}$NF~/m|M/{x=$NF/1024}$NF~/t|T/{x=$NF*1024}$NF~/g|G/{x=$NF/1;}{;printf "%0.9f",x}')

if [ -z "$sizelvgib" ] ; then
sizelvgib2=$(lvdisplay |awk -v a="$lvx" '$0~a"\n"{for(i=1;i<=NF;i++)if($i~"LV Size"){split($i,d," ");gg=d[4];s=d[3];sub("<","",s);if(gg~/KiB|KB/){x=s/1024/1024}if(gg~/MiB|MB/){x=s/1024}if(gg~/TiB|TB/){x=s*1024}if(gg~/GiB|GB/){x=s}}}END{printf "%0.9f\n",x}' RS="Logical volume" FS="\n" )
[ ! -z "$sizelvgib2" ] && sizelvgib="$sizelvgib2"
fi

if [ -z "sizelvgib" ] ; then
sizemnt=$(df -BG -P|grep "$vgx-$lvx "|awk '/G/{sub("G","",$2);print $2}' )
[ ! -z "$sizemnt" ] && sizelvgib="$sizemnt"
fi

if [ -z "$sizelvgib" ] ; then
echo "[$vgx-$lvx] [LV] device size bilgisi bulunamadi !!"
errormsg
fi

sizelvgibshow=$(awk -v a="$sizelvgib" 'BEGIN{printf "%0.2f",a}')
}


pvsize_cal() {
###PV size gib
sizepvx=$(pvs --units g "$devdisk" 2>/dev/null|awk 'NR>1{sub("<","",$(NF-1));x=$(NF-1);sub(".$","",x);print x}')

if [ -z "$sizepvx" ] ; then
sizepvx=$(pvs "$devdisk" 2>/dev/null |awk 'NR>1{sub("<","",$(NF-1));x=$(NF-1);if(x~"g")s=x;;if(x~"t")s=x*1024;if(x~"m")s=x/1024;if(x~"k")s=x*1024/1024;printf "%0.9f",s }')
fi

if [ -z "$sizepvx" ] ; then
sizepvx=$(pvs 2>/dev/null |grep "$devdisk " |awk '$(NF-1)=="0"{exit}$(NF-1)~/</{sub("<","",$(NF-1))}$NF~/k|K/{x=$(NF-1)/1024/1024}$(NF-1)~/m|M/{x=$(NF-1)/1024}$(NF-1)~/t|T/{x=$(NF-1)*1024}$(NF-1)~/g|G/{x=$(NF-1);}{;printf "%0.9f",x}')
fi

if [ -z "$sizepvx" ] ; then
echo "[PV] disk size bilgisi bulunamadi !!"
errormsg
else
sizepv=$(awk -v a="$sizepvx" 'BEGIN{printf "%.2f",a}')
fi


#eger 00 varsa yuvarlama ( Gerek yok pvs zaten size degerlerini ".00" formatinda tutuyor.
#sizepv=$(echo "$sizepvx"|sed 's/\00$//')
#sizepv=$(awk -v a="$sizepvx" 'BEGIN{printf "%.2f",a}')
#sizepv=$(awk -v a="$sizepvx" 'BEGIN{if(a~".00$")printf "%.2f",a;else print a}')

#if [ -z "$sizepv" ] ; then
#echo "[$disk] PV size bilgisi bulunamadi !! "
#errormsg
#fi
}


disksize_cal() {
##lsblk kusuratlari gostermede daha basarili !!
if [ $lsblkok -eq 1 ] ; then
sizedsk=$(lsblk -d -b "$devdisk"|awk 'END{x=$4/1024/1024/1024;;printf "%0.2f\n",x}')
fi

if [ -z "$sizedsk" ] ; then
if [ $partedok -eq 1 ] ; then
sizedsk=$(parted -s "$devdisk" unit Gib print 2>/dev/null|grep Disk|awk 'NR==1{sub("GiB","",$NF);x=$NF;printf "%0.2f\n",x}' )
fi
fi

##fdisk in var oldugunu varsayiyorum !!
if [ -z "$sizedsk" ] ; then
sizedsk=$(fdisk -l "$devdisk"|awk -F',' '/Disk/{if($NF~"bytes"){split($NF,d," ");x=d[1];};if($(NF-1)~"bytes"){split($(NF-1),d," ");x=d[1];}if(x)printf "%0.2f\n",x/1024/1024/1024;exit}')
fi

if [ -z "$sizedsk" ] ; then
echo "[$devdisk] disk size bilgisi bulunamadi !! "
errormsg
fi
}



pvsizex() {

###eger 1020m gibi bir deger varsa "0.2f" den dolayi 0.9961 e yuvarlaniyor.
pvsize_cal
sizepv_after=$sizepv

disksize_cal



#pvresize sonrasi Yeni disk(sizepv_after) alan kontrolu
sizeok=$(awk -v a=$sizedsk -v b=$sizepv_after 'BEGIN{if(a-b<=0.1)print "a-b"}')
if [ -z "$sizeok" ] ; then
echo
printit 30
if [[ "$freeraw_new" -eq 1 ]] || [[ "$freeraw_old" -eq 1 ]] ; then
echo "[pvresize] islemine ragmen (Free RAW) alan [PV] diskine aktarilamamis olabilir !!"
echo "Eger (Free RAW) alan bulunmasina ragmen yeni disk size degeri sistem tarafindan taninmadiysa sistemin reboot edilmesi gerekiyor olabilir .. !! "
printit 30
echo
fi

else

echo
printit 50
echo "[pvresize] islemi BASARILI [OK] "
printit 50
sleep 2

##################
[[ "$diskother" = "ok" ]] && disk=$diskdx
echo "[$disk] diski ( -> $sizedsk Gib ) alani ile [PV] disk ( -> $sizepv_after Gib ) alani esit gorunuyor .. "
echo "[$disk] diski uzerinde FARKLI bir (Free RAW) alan bulunamadi !! "
sleep 1
##################

sizepv_dif=$(awk -v a="$sizepv_before" -v b="$sizepv_after" 'BEGIN{s=b-a;if(s>0)print "OK"}')
if [ ! -z "$sizepv_dif" ] ; then
sizepv_dif_gib=$(awk -v a="$sizepv_before" -v b="$sizepv_after" 'BEGIN{s=b-a;if(s>0)print s}')
echo "[pvresize] sonrasi [$disk] diski uzerinden [PV] disk uzerine ( $sizepv_dif_gib Gib ) buyuklugunde bir alan aktarildi [OK] "
fi
printit 50
echo;echo
echo "[$vgx] [VG] icin kullanilabilir Free alan bilgisi kontrol ediliyor ... "
printit 70
sleep 1
fi
}



usersizemib() {
usersizex=$1
usersizemibx=1

case $usersizex in
*t)sizeusermib=$(awk -v a="$usersizex" 'BEGIN{printf "%0.9f",a*1048576}')
usersizemibx=0
;;
*g)sizeusermib=$(awk -v a="$usersizex" 'BEGIN{printf "%0.9f",a*1024}')
usersizemibx=0
;;
*m)sizeusermib=$(awk -v a="$usersizex" 'BEGIN{printf "%s",a/1}')
;;
*k)sizeusermib=$(awk -v a="$usersizex" 'BEGIN{printf "%0.9f",a/1024}')
;;
*b)sizeusermib=$(awk -v a="$usersizex" 'BEGIN{printf "%0.9f",a/1048576}')
;;
*)echo "user size bilgileri hesaplanirken tanimsiz unit bilgisi tespit edildi !! "
;;
esac


[ ! -z "$sizeusergib" ] && isgibtomib=$(awk -v a="$sizeusergib" 'BEGIN{if(a>=1)print "OK"}')
[ ! -z "$isgibtomib" ] && usersizemibx=0


if [ -z "$sizeusermib" ] ; then
echo "Size bilgisi kontrolleri sirasinda hata olustu !! -> [usersizemib] "
errormsg
fi
sizeusermibshow=$(awk -v a="$sizeusermib" 'BEGIN{printf "%0.2f",a}')
#sizeusermibshow=$(awk -v a="$sizeusermib" 'BEGIN{if(a~".00$")printf "%.2f",a;else print a}')
}


disktopvresizechk() {
printit 50
#echo -e "\n$disk ->(dev) ile $disk ->(PV) arasinda Size kontrolu yapilacaktir .. "


###PVRESIZE(growpart?) ONCESI###
##daha onceden growpart ile free alan aktarimi yapilmissa disk ve PV disk arasida size farki kontrolu
######
pvsize_cal
sizepv_before=$sizepv
###"GrowPart yapildigi varsayilir !! "

##Gerek varmi bilemedim. ?
#pvsizex



####PVRESIZE####
#--------------#
#Disk uzerinde Free RAW alan aranip bilgi verildikten sonra bu Free Space alanin daha onceden VG e aktarildigi varsayilir..
pvresizemsg
pvresize "$devdisk"
printit 70

###pvresize sonrasi yeni free space gelmis olmasi gerekiyor
#sizepv=$(pvs|grep "/$disk "|awk '{sub("<","",$5);sub("g","",$5);x=$5;printf "%0.2f\n",x}' )
#sizepv=$(pvs $devdisk 2>/dev/null |awk 'NR>1{sub("/dev/","",$1);dev=$1;x=$(NF-1);if(x==0)s=0; else {sub("<","",x);if(x~"g")s=x;;if(x~"t")s=x*1024;if(x~"m")s=x/1024;if(x~"k")s=x*1024/1024};;printf "%0.2f\n",s}')
#sizepv=$(pvs $devdisk 2>/dev/null |awk 'NR>1{sub("<","",$(NF-1));x=$(NF-1);if(x~"g")s=x;;if(x~"t")s=x*1024;if(x~"m")s=x/1024;if(x~"k")s=x*1024/1024;printf "%0.2f\n",s }')


### PVRESIZE SONRASI disk ve VG alani kontrolu
##Free Alanin PV diskinden VG alanina aktarilmis olmasi gerekir..
pvsizex
}


partdskchk() {
pvsize_cal
sizedskpv=$sizepv
disksize_cal
sizechk=$(awk -v a=$sizedsk -v b=$sizedskpv 'BEGIN{if(a-b>0.1)print "OK"}')
}


pvresizex() {
echo
printit 30
echo "[$disk] diski icin Free Alan Kontrolleri ... "
printit 30
sleep 2

##lsblk kontrol
#lsblkchk

## Eger free space disk(sda) de yer aliyor ve islem yapilmak istenen PV diski(sda2) bir partition ise bu durumda free space in onceden bu partitiona aktarilmis olmasi zorunludur..
diskpartchk



#PVRESIZE_pre
###============================###


##freeraw_old=1 ise Free alan diske aktarilmis fakat growpart yapilmadigi icin part diske aktarim yapilmamis demektir ..
### pvresize durumu , hem sda icin hem sda3 icin gecerli bir durum olabilir..
### onceden bu disklere atanmis fakat LVM tarafina aktarilamamis Free RAW alan olabilir...


#### YENI FREE RAW alan varsa
if [[ "$freeraw_new" -eq 1 ]] ; then
if [ "$isdisk" = "part" ] ; then
growpartmsg

####Yeni Free alan varken Part ve PV_disk arasinda kontrol
##Eger Disk de free alan varsa ve 'PV_disk part' ise growpart yapilmali !!
partdskchk
## Eger 'PV_disk part' uzerinde daha onceden eklenmis fakat PV disk tarafina aktarilmamis bir Free Alan varsa
[ ! -z "sizechk" ] && disktopvresizechk

##else
##Yeni Free alan varken Disk ve PV_disk arasinda Free RAW alan kontrolu
##Bu islem "freeraw_pvs" ile Yeni Free alanin olup olmadigina bakilmaksizin yapiliyor ARTIK..
#disktopvresizechk

fi
fi


if [[ "$freeraw_old" -eq 0 ]] && [[ "$freeraw_pvs" -eq 0 ]] ; then
echo -e "\n-> [pvresize] asamasi pass geciliyor ... "
printit 50
sleep 1
fi


#### PV disk ile Disk/Part arasinda Free RAW alan varsa
if [[ "$freeraw_pvs" -eq 1 ]] ; then
disktopvresizechk
fi



#### MEVCUT FREE RAW alan yoksa
if [[ "$freeraw_old" -eq 1 ]] ; then

#PV_Disk tarafina henuz aktarilmamis bir FREE RAW alan varsa
if [ "$isdisk" = "part" ] ; then
growpartmsg
partdskchk
[ ! -z "$sizechk" ] && disktopvresizechk
else
disktopvresizechk
fi

fi



## iptal -08-11-2025 -> Sadece 0.1 Gib(1024 Mib ?) a kadar Free alan icin islem yapilabilir.. ->> [m$]
freevgsize=$(vgs "$vgx"|awk 'NR>1'|awk '$NF=="0"{exit}$NF~/</{sub("<","",$NF)}{print $NF}')
#freevgsize=$(vgs|grep "$vgx "|awk '$NF=="0"{exit}$NF~"m$"{exit}$NF~/</{sub("<","",$NF)}{print $NF}')
#freevgsize=$(vgs "$vgx"|awk 'END{if($NF=="0"){exit};if($NF~/</){sub("<","",$NF)}print $NF}')

freevggib=$(vgs --units g "$vgx"|awk 'END{if($NF=="0g"||$NF=="0G"){exit};if($NF~/</){sub("<","",$NF)};sub(".$","",$NF);print $NF}')

if [ -z "$freevggib" ] ; then
freevggib=$(vgs|grep "$vgx "|awk '$NF=="0"{exit}$NF~/</{sub("<","",$NF)}$NF~/k|K/{x=$NF/1024/1024}$NF~/m|M/{x=$NF/1024}$NF~/t|T/{x=$NF*1024}$NF~/g|G/{x=$NF;}{;printf "%0.2f",x}')

freevggib2=$(vgs|grep "$vgx "|awk '$NF=="0"{exit}$NF~/</{sub("<","",$NF)}$NF~/k|K/{x=$NF/1024/1024}$NF~/m|M/{x=$NF/1024}$NF~/t|T/{x=$NF*1024}$NF~/g|G/{x=$NF;}{;printf "%0.9f",x}')

else
freevggib2=$freevggib
fi

[[ ! -z "$freevggib2" ]] && freevggib=$freevggib2

#isfree=$(awk -v n1="$freevggib" -v n2="0.1" 'BEGIN {(n1>n2 ? x="ok" : x="notok");print x }')

if [ ! -z "$freevgsize" ] ; then
echo "[$vgx] VG icinde ($freevggib Gib [$freevgsize] ) kadar (Free LV) alan bulundu ... "
printit 70


##LV device ok !!
islvxok=$(lvs|awk -v a="$lvx" -v b="$vgx" 'NR>1&&$1==a&&$2==b{print $1}')
[ -z "$islvxok" ] && lvxisok=0 || lvxisok=1


if [ $lvxisok -ne 1 ] ; then
echo "[LV] device bilgilerine erisilemedi !! "
sleep 3
echo
#[new] ile YENI DISK olusturulabilir !!
echo "[LV] device olusturma islemlerine devam ediliyor ... "
sleep 2
#errormsg
fi




### lv_size ###
lvsizemib
lvsizegib

if [ ! -z "$sizelvmib" ] ; then
lvsizemibok=$(awk -v a="$sizelvmib" 'BEGIN{if(a>=1024)print "OK"}')
if [ ! -z "$lvsizemibok" ] ; then
lvsize="$sizelvgibshow"
lvsizemibx=0
else
lvsizemibx=1
lvsize="$sizelvmibshow"
fi
fi



#### usersize ####
if [ ! -z "$size" ] ; then
usersizegib $sizec
usersizemib $sizec
else
### Free size ###
usersizegib $freevgsize
usersizemib $freevgsize
fi



if [ ! -z "$sizeusermib" ] ; then
usersizemibok=$(awk -v a="$sizeusermib" 'BEGIN{if(a>=1024)print "OK"}')
if [ ! -z "$usersizemibok" ] ; then
usersize="$sizeusergibshow"
usersizemibx=0
else
usersizemibx=1
usersize="$sizeusermibshow"
fi
fi


if [ "$usersizemibx" -eq 0 ] ; then
usersizeunit=Gib
newlvsizeunit=Gib
if [ ! -z "$lvsizemibx" ] && [ "$lvsizemibx" -eq 0 ] ; then
newlvsize=$(awk -v a="$lvsize" -v b="$usersize" 'BEGIN{x=a+b;printf "%0.9f",x}')
lvsizeunit=Gib
else
lvsizeunit=Mib
newlvsize=$(awk -v a="$lvsize" -v b="$usersize" 'BEGIN{xa=a/1024;x=xa+b;printf "%0.9f",x}')
fi
fi


if [ "$usersizemibx" -eq 1 ] ; then
usersizeunit=Mib
if [ ! -z "$lvsizemibx" ] && [ "$lvsizemibx" -eq 1 ] ; then
newlvsize=$(awk -v a="$lvsize" -v b="$usersize" 'BEGIN{x=a+b;printf "%0.9f",x}')
lvsizeunit=Mib
newlvsizeunit=Mib
else
newlvsizeunit=Gib
lvsizeunit=Gib
newlvsize=$(awk -v a="$lvsize" -v b="$usersize" 'BEGIN{xb=b/1024;x=a+xb;printf "%0.9f",x}')
fi
fi


#newlvsize2=$(awk -v a="$newlvsize" 'BEGIN{if(a~".00$")printf "%.2f",a;else print a}')

newlvsizechange=$(awk -v a="$newlvsize" 'BEGIN{if(a>=1024)print a/1024}')
if [ ! -z "$newlvsizechange" ] ; then
case $newlvsizeunit in
Gib)newlvsize2=$(awk -v a="$newlvsize" 'BEGIN{printf "%0.9f",a/1024}')
newlvsizeunit=Tib
;;
Mib)newlvsize2=$(awk -v a="$newlvsize" 'BEGIN{printf "%0.9f",a/1024}')
newlvsizeunit=Gib
;;
esac
fi

[ ! -z "$newlvsize2" ] && newlvsize="$newlvsize2"
newlvsizeshow=$(awk -v a="$newlvsize" 'BEGIN{printf "%0.2f",a}')
#newlvsizeshow=$(awk -v a="$lvsize" 'BEGIN{if(a~".00$")printf "%.2f",a;else print a}')



####
lvsizechange=$(awk -v a="$lvsize" 'BEGIN{if(a>=1024)print a/1024}')
if [ ! -z "$lvsizechange" ] ; then
case $lvsizeunit in
Gib)lvsize2=$(awk -v a="$lvsize" 'BEGIN{printf "%0.9f",a/1024}')
lvsizeunit=Tib
;;
Mib)lvsize2=$(awk -v a="$lvsize" 'BEGIN{printf "%0.9f",a/1024}')
lvsizeunit=Gib
;;
esac
fi

[ ! -z "$lvsize2" ] && lvsize="$lvsize2"
lvsizeshow=$(awk -v a="$lvsize" 'BEGIN{printf "%0.2f",a}')
#lvsizeshow=$(awk -v a="$lvsize" 'BEGIN{if(a~".00$")printf "%.2f",a;else print a}')



####
usersizechange=$(awk -v a="$usersize" 'BEGIN{if(a>=1024)print a/1024}')
if [ ! -z "$usersizechange" ] ; then
case $usersizeunit in
Gib)usersize2=$(awk -v a="$usersize" 'BEGIN{printf "%0.9f",a/1024}')
usersizeunit=Tib
;;
Mib)usersize2=$(awk -v a="$usersize" 'BEGIN{printf "%0.9f",a/1024}')
usersizeunit=Gib
;;
esac
fi

[ ! -z "$usersize2" ] && usersize="$usersize2"
usersizeshow=$(awk -v a="$usersize" 'BEGIN{printf "%0.2f",a}')
#usersizeshow=$(awk -v a="$usersize" 'BEGIN{if(a~".00$")printf "%.2f",a;else print a}')


[ ! -z "$sizec" ] && \
echo "[$vgx] VG icin '+$sizec ($usersizeshow $usersizeunit)' kadar (Free LV) alan bilgisi kullanilarak islem yapilacak ... " || \
echo "[$vgx] VG icin '+$usersizeshow $usersizeunit' kadar (Free LV) alan bilgisi kullanilarak islem yapilacak ... " || \
sleep 4
echo "islem sonrasi : Yeni [ $vgx-$lvx ] [LV] Size bilgisi :  $newlvsizeshow $newlvsizeunit ( $lvsizeshow $lvsizeunit + $usersizeshow $usersizeunit ) ]"


sleep 2


else
echo xx $usersizechange xx $usersize
exit
echo
printit 50
echo "->> [$vgx] [VG] icinde (Free LV) alan bulunamadi !! "
printit 30
echo
#errormsg

#if [ "$pvlayout" == "linear" ] ; then
if [ "$1" = "ext" ] ; then
echo "EXTEND[ext] islemleri yapilamiyor... !! "
if [[ "$growpartprint" -eq 1 ]] ; then
echo
echo "[growpart $grow_devdisk $diskprt] komutunu calistirmaniz gerekiyor olabilir ... "
sleep 2
echo
echo "[growpart] uygulamasi kullanilamiyor ise [fdisk] komutu ile [$disk] partitionu silip tekrardan olusturmaniz gerekiyor olabilir .... "
echo
sleep 2
fi
errormsg
fi

echo "CREATE[new] islemlerine devam ediliyor ... "
fi
printit 70

#fi

sleep 1
#lsblk $devdisk
#firstsize=$(lsblk "$devdisk"|grep "$lvx "|awk '{print $4}')
echo
echo "ISLEM ONCESI"
process_check
echo
#####iptal ettim 26-08-2023
#echo "pvresize tekrar uygulaniyor..."
#printit 30
#echo
#pvresize $devdisk
#printit 30
#sleep 1
#if [ $lsblkok -eq 1 ] ; then
#printit 30
#lsblk $devdisk
#fi
#printit 30
}


pvcreatex_pre() {
##lsblk ve LVM komutlari default olarak Gibibyte(Gib) gosterim yapar. Yani 1024 un katlari kullanilir.
##Gigabyte (GB)
totalsizegib=$(lsblk -b -d $devdisk|awk 'NR>1{s=$4/1024/1024/1024;printf "%0.9f",s}')
#totalsizegibw=$(echo $totalsizegib|sed 's/.$//')
#totalsizeok=$(echo "$totalsizegibw"|awk '{print tolower($0)}')
if [ -z "$totalsizegib" ] ; then
echo "Disk alani hesaplanirken bir sorun olustu !! "
errormsg
fi

if [ ! -z "$size" ] ; then
usersizegib $sizec
isavsizeok=$(awk -v a="$totalsizegib" -v b="$sizeusergib" 'BEGIN{if(a<b)print "NOK"}')
if [ ! -z "$isavsizeok" ] ; then
totalsizegibshow=$(awk -v b="$totalsizegib" 'BEGIN{printf "%0.2f",b}')
#sizeusergibshow=$(awk -v b="$sizeusergib" 'BEGIN{printf "%0.2f",b}')
echo "Disk uzerinde kullanilabilir maximum alan [ $totalsizegibshow Gib < $sizeusergibshow Gib ] olarak gorunuyor !! "
errormsg
fi
fi
}


pvcreatex() {
pvcreatex_pre
printit 70
pvcreate "$devdisk" ; errchk $? "pvcreate"
echo "[$devdisk] yeni bir [PV] diski olarak olusturuldu .. "
sleep 1

################
### Yucel Gemici ->> Tum disk kullanilacak sekilde set ettim. Uygulama tarafindan Fiziksel disk bolumlenmesi desteklenmiyor.. !!!
#pvcreate --setphysicalvolumesize "$1" "$devdisk" ; errchk $? "pvcreate"
################

#fi
printit 70
}


freelv_oldoschk() {
disk=$1
el=$(uname -r|sed 's/.*el\([0-9]*\).*/\1/')
case "$el" in
4|5)
sizepvx_old=$(pvs --units g "$disk" 2>/dev/null|awk 'NR>1{sub("<","",$(NF-1));x=$(NF-1);sub(".$","",x);printf "%.2f",x}'
if [ -z "$sizepvx_old" ] ; then
sizepvx_old=$(pvs $disk 2>/dev/null|awk 'NR>1{sub("<","",$NF);x=$(NF);if(x==0){print 0;exit};if(x~"G")s=x;;if(x~"T")s=x*1024;if(x~"M")s=x/1024;if(x~"K")s=x/1024/1024;printf "%0.2f",s }')
fi
if [ -z "$sizepvx_old" ] ; then
freelv=0
else
freelv=$(awk -v a="$sizepvx_old" 'BEGIN{if(a>0)printf "%.0f",a}')
fi
;;
6|7|8)echo "[$disk] diskinde (Free LV) alan bulunamadi [oldoscheck OK] !! "
freelv=0
;;
*)echo "Sistem destegi bulunmamaktadir.. $(uname -r) " ; freelv=0
;;
esac
printit 50
}


usersizegib() {
sizex=$1

case $sizex in
*t)sizeusergib=$(awk -v a="$sizex" 'BEGIN{printf "%0.9f",a*1024 }')
;;
*g)sizeusergib=$(awk -v a="$sizex" 'BEGIN{printf "%s",a/1 }')
;;
*m)sizeusergib=$(awk -v a="$sizex" 'BEGIN{printf "%0.9f",a/1024 }')
;;
*k)sizeusergib=$(awk -v a="$sizex" 'BEGIN{printf "%0.9f",a/1024/1024 }')
;;
*b)sizeusergib=$(awk -v a="$sizex" 'BEGIN{printf "%0.9f",a/1024/1024/1024 }')
;;
*)echo "Size bilgisi icinden unit bilgisi tespit edilemedi -> [$sizex]  !! "
esac

if [ -z "$sizeusergib" ] ; then
echo "Size bilgisi kontrolleri sirasinda hata olustu !!  [usersizegib] "
errormsg
fi
sizeusergibshow=$(awk -v a="$sizeusergib" 'BEGIN{printf "%0.2f",a}')
#sizeusergibshow=$(awk -v a="$sizeusergib" 'BEGIN{if(a~".00$")printf "%.2f\n",a;else print a}')
}


lvfreesizechk() {
usereqsize=$1
lvfreesize=$2

#usersizegib "$usereqsize"
lvsizechk=$(awk -v a="$lvfreesize" -v b="$sizeusergib" 'BEGIN{if(a>=b)print "OK"}')
}

pesizex() {
if [ -z "$vgx" ] ; then
echo "VG bilgisi bulunamadi !! "
errormsg
fi

pesizemibx=$(vgdisplay "$vgx"|grep "PE Size"|awk '{print $NF}')
case $pesizemibx in
GB|GiB)pesizemib=$(vgdisplay $vgx|grep "PE Size"|awk '{print $(NF-1)/1024}')
;;
MB|MiB)pesizemib=$(vgdisplay $vgx|grep "PE Size"|awk '{print $(NF-1)}')
;;
KB|KiB)pesizemib=$(vgdisplay $vgx|grep "PE Size"|awk '{print $(NF-1)*1024}')
;;
B)pesizemib=$(vgdisplay $vgx|grep "PE Size"|awk '{print $(NF-1)*1024*1024}')
;;
*)echo "PE size tespit edilemedi !!"
errormsg
;;
esac
}

pesizechk() {
###Pe size ( Physical Extent ) most default : 4MiB
pesizeunit="Mib"
pesizex

###sizeusergib = gib cinsinden
if [ ! -z "$size" ] ; then
usersizegib $sizec

#gib-mib cevrimi
usersizemib $sizec
##sizeusermib degeri elde edildi..

####
pesize_warn=$(awk -v a="$pesizemib" -v b="$sizeusermib" 'BEGIN{if(a>b)print "OK"}')
if [ ! -z "$pesize_warn" ] ; then
echo "LVM PE Size [$pesizemib Mib] alani , istenilen size [$sizec] degerinden BUYUK oldugu icin [1 x PE] buyuklugunde alan kullanilacaktir !! "
sleep 1
printit 30
echo
echo "islem sonrasi [pe_warn] : Yeni [ $vgx-$lvx ] [LV] Size bilgisi :  $newlvsizeshow $newlvsizeunit ( $lvsizeshow $lvsizeunit + $pesizemib $pesizeunit ) ]"
printit 30

freelvpe=$(vgdisplay $vgx|grep "PE Size"|awk 'END{print $(NF-1) $(NF)}')
fi
fi
}

process_check() {
printit 30
[[ $lsblkok -eq 1 ]] && lsblk $devdisk
printit 30
pvs "$devdisk"
printit 30
[ ! -z "$vgx" ] && vgs "$vgx"
printit 30
[ ! -z "$vgx" ] && [ ! -z "$lvx" ] && lvs "$vgx/$lvx" 2>/dev/null | sed 's/\(.*\)Pool.*/\1/' && printit 30
echo
[ ! -z "$lvx" ] && lvs -v --segments 2>/dev/null | awk -v a="$lvx" 'NR==1||$1==a' && printit 30
[ -z "$pesizemib" ] && pesizex

[ ! -z "$vgx" ] && [ ! -z "$lvx" ] && pvs -v --segments 2>/dev/null | awk -v a="$vgx" -v b="$lvx" -v c="$pesizemib" 'NR==1{print;next}$2==a&&$9==b{if($8>262143)printf "%s %s %2.f %s\n",$0," ->> ",($8*c)/1048576,"tib";else printf "%s %s %2.f %s\n",$0," ->> ",($8*c)/1024,"gib"}' && printit 30
echo
#pvs -o+lv_layout,stripes,devices,size | awk -v a="$vgx" 'NR==1||$2==a'
#[ ! -z "$vgx" ] && [ ! -z "$lvx" ] && lvs -o+lv_layout,stripes,devices,size | awk -v a="$vgx" -v b="$lvx" 'NR==1||$2==a&&$1==b'
}

freelvchk() {
vgfree=$(vgs "$vgx" 2>/dev/null|awk 'NR>1{sub("<","",$NF);printf "%s",$NF}')
case $vgfree in
*G|*g)
freelvgib=$(vgs 2>/dev/null|grep "$vgx "|awk '$NF~/</{sub("<","",$NF)};{printf "%0.2f",$NF/1}')
freelvgib2=$(vgs 2>/dev/null|grep "$vgx "|awk '$NF~/</{sub("<","",$NF)};{printf "%0.9f",$NF/1}')
freelvmib=$(vgs 2>/dev/null|grep "$vgx "|awk '$NF~/</{sub("<","",$NF)};{printf "%0.2f",$NF*1024}')
;;
*T|*t)
freelvgib=$(vgs 2>/dev/null|grep "$vgx "|awk '$NF~/</{sub("<","",$NF)};{printf "%0.2f",$NF*1024}')
freelvgib2=$(vgs 2>/dev/null|grep "$vgx "|awk '$NF~/</{sub("<","",$NF)};{printf "%0.9f",$NF*1024}')
freelvmib=$(vgs 2>/dev/null|grep "$vgx "|awk '$NF~/</{sub("<","",$NF)};{printf "%0.9f",$NF*1024*1024}')
;;
*M|*m)
freelvgib=$(vgs 2>/dev/null|grep "$vgx "|awk '$NF~/</{sub("<","",$NF)};{printf "%0.2f",$NF/1024}')
freelvgib2=$(vgs 2>/dev/null|grep "$vgx "|awk '$NF~/</{sub("<","",$NF)};{printf "%0.9f",$NF/1024}')
freelvmib=$(vgs 2>/dev/null|grep "$vgx "|awk '$NF~/</{sub("<","",$NF)};{printf "%0.2f",$NF/1}')
;;
*K|*k)
freelvgib=$(vgs 2>/dev/null|grep "$vgx "|awk '$NF~/</{sub("<","",$NF)};{printf "%0.2f",$NF/1024/1024}')
freelvgib2=$(vgs 2>/dev/null|grep "$vgx "|awk '$NF~/</{sub("<","",$NF)};{printf "%0.9f",$NF/1024/1024}')
freelvmib=$(vgs 2>/dev/null|grep "$vgx "|awk '$NF~/</{sub("<","",$NF)};{printf "%0.2f",$NF/1024}')
;;
0) [[ -z "$freelvgib" ]] && freelvgib="0.00 gib" ; echo "$vgx [VG] icin Free [LV] alan bulunamadi !! : [ $freelvgib ] "
;;
*)freelvgib=$(pvs "$devdisk" 2>/dev/null|awk 'NR>1{printf "%s",$NF}')
echo "Free LV bilgisi tespit edilemedi !! Uygulama bu formata destek vermiyor : [ $freelvgib ] "
errormsg
;;
esac

freelvgb=$(awk -v a="$freelvgib" 'BEGIN{s=a*(1073741824)/1000000000;printf "%.2f",s}')
#freelvgibshow=$(awk -v a="$freelvgib2" 'BEGIN{printf "%.9f",s}')
}

lvextendx() {
op=$1 #( ext/new)

if [ ! -z "$2" ] ; then
case "$2" in
striped)for pvdskdev in ${stripedisks[@]}; do
disk="$pvdskdev"
pvresizex "$op"
done
;;
*)echo "Eksik disk bilgisi !!"
errormsg
;;
esac
else
pvresizex "$op"
fi


#free lv alan gib->gb cevrimi
freelvchk

#guncelleme 1m bile olsa uygulaniyor artik..
freelvok=$(awk -v a="$freelvgib2" 'BEGIN{if(a>0)print "OK"}')
if [ -z "$freelvok" ] ; then
echo "[VG->$vgx] icin free alan bilgisi = [ $freelvgib Gib ( $freelvgb GB ) ] "
echo "[VG->$vgx] icin yeterli buyuklukte (Free LV) alan bulunamadi !! "

#echo "->> Eski sistemler icin yeniden tarama yapiliyor ... "
printit 50
sleep 1
#freelv_oldoschk $devdisk
#[ ! -z "$freelv" ] && freelvgb=$freelvf

errormsg

##extend icin en az 0.1GB(0.093Gib)/100MB(95.36Mib) alan gerekli
#freegb=$(awk -v a="$freelv" 'BEGIN{if(a>=0.1)print "OK"}')


else

#istenilen alan icin free LV alani yeterli mi ?

issizeok=$(awk -v a="$freelvgib2" -v b="$sizeusergib" 'BEGIN{if(a>=b)print "OK"}')
if [ -z "$issizeok" ] ; then
echo
printit 50
echo "->> [$vgx] [VG] icinde yeterli (Free LV) alan bulunamadi !! -> [ $freelvgib Gib ( $freelvgb GB ) < $sizeusergibshow Gib ] "
printit 50
errormsg
fi


#################
case $1 in
"ext")
echo "[VG->$vgx] -> [$disk] diski kullanilarak [LV->$lvx] device EXTEND islemi baslatiliyor ... "
sleep 2


pesizechk
freelvchk

if [ ! -z "$size" ] ; then
lvfreesizechk "$sizeusergib" "$freelvgib2"
if [ -z "$lvsizechk" ] ; then
echo
printit 50
echo "[Extend] islemi icin [$vgx] [VG] uzerinde yeterli buyuklukte alan bulunmuyor -> [ $freelvgib Gib < $sizeusergibshow Gib ] !! "
printit 50

if [[ "$growpartprint" -eq 1 ]] ; then
echo
echo "[growpart $grow_devdisk $diskprt] komutunu calistirmaniz gerekiyor olabilir ... "
sleep 2
echo
echo "[growpart] uygulamasi kullanilamiyor ise [fdisk] komutu ile [$disk] partitionu silip tekrardan olusturmaniz gerekiyor olabilir .... "
echo
sleep 2
fi

errormsg
fi
fi


###size yoksa
if [ -z "$size" ] ; then
lvextend -l +100%FREE "$lvmmapperdev"
lvextend_st=$?
else
lvextend -L +${sizec} "$lvmmapperdev"
lvextend_st=$?
fi


if [ $lvextend_st -eq 0 ] ; then
lvsizegib
[ ! -z "$freelvpe" ] && sizec="$freelvpe"
[ -z "$size" ] && usedlvsize="$freelvgib Gib" || usedlvsize="$sizeusergibshow Gib"
printit 50
echo "-> [$lvx] isimli [LV] device [+$usedlvsize ] kadar alan kullanilarak extend edildi .. [OK] "
printit 50

else

printit 50
echo "->> [$lvx] isimli [LV] device extend edilirken bir sorun olustu !! "
errormsg
fi

;;


"new")
##Yeni LV hazir mi
if [ ! -z "$lvcreatexx" ] ; then
case "$lvcreatexx" in
1)echo "Yeni [LV->$lvx] device bir onceki asamada olusturulmustu .. [OK] "
sleep 2
errormsg
;;
esac
#11)##new parametresi ile extend islemleri yapilamaz !!
#echo "[$lvx] isminde YENI bir [LV] device mevcut oldugu icin [new] parametresi ile extent islemleri yapilamiyor !! "
#errormsg
#;;

else
echo "'new' parametresi icin EXTEND islem destegi kaldirilmistir !! (09-10-2023) "
fi

;;
esac

fi
echo
}


vgextendx() {
#pvresizex
vgextenddsk="$2"
echo
printit 70
[[ "$diskother" = "ok" ]] && disk=$(echo "$vgextenddsk"|sed 's/\/dev\///')
echo "[$disk] diski kullanilarak [$vgx] isimli [VG] [vgextend] edilecek !! "
printit 30
sleep 1
echo "-> [vgextend] islemini kesmek icin 'Ctrl-C' tuslarini kullanabilirsiniz !! "
printit 30
sleep 2

ispvsok=$(pvs "$vgextenddsk" 2>/dev/null|awk -v a="$vgx" '$2==a{print "OK"}')
if [ -z "$ispvsok" ] ; then
echo "-> [vgextend] islemi baslatiliyor ... "
sleep 3
vgextend "$vgx" "$vgextenddsk" ; errchk $? "vgextend"
vgextendok=1
else
pvsdiskn=$(pvs 2>/dev/null|awk -v a="$vgx" '$2==a{sub("/dev/","");printf "%s ",$1}')
pvscx=$(echo "$pvsdiskn"|awk 'BEGIN{if(NF>1)print "ok"}')
[ ! -z "$pvscx" ] && ekler="diskleri" || ekler="diski"
if [ ! -z "$pvsdiskn" ] ; then
echo "->> [$vgx] VG bilgisi [ $pvsdiskn] $ekler uzerinde zaten mevcut durumda gorunuyor ..."
sleep 2
fi
echo
echo "->> [$disk] diski uzerinde [$vgx] ismindeki [VG] zaten tanimli gorunuyor !! "
vgextendok=0
sleep 2
fi

printit 70
}


resizemsg() {
if [ -z "$1" ] ; then
echo "filesystem resize uygulamasi([$2]) bulunamadi.. !! "
errormsg
fi
}


resizepck() {
case "$1" in
xfs|XFS) app=xfs_growfs;fpath=$(which $app); resizemsg "$fpath" $app
;;
ext[3-4]|EXT[3-4]) app=resize2fs;fpath=$(which $app); resizemsg "$fpath" $app
;;
*) echo "xfs/ext[34] haricindeki filesystemler icin filesystem EXTEND islemi desteklenmiyor .. !! "
esac
}


pvscanx() {
echo "Disk taramasi yapiliyor..."
ls /sys/class/scsi_host/ | while read host ; do
echo "- - -" > /sys/class/scsi_host/$host/scan
done
echo "Disk taramasi tamamlandi.. [OK] "
printit 30
}


isntmounted() {
dev="$1"
fst=$(file -sL "$(readlink -e "$dev")"|awk -F'[:,;(]' '{print $2}'|awk '{print $2}' )
}


fschk() {
#chkmounted=$(lsblk -o NAME,MOUNTPOINT "$1"|awk 'NR>1&&$2!=""{print $2}')
#mountp=$(lsblk|grep "$1 "|awk 'END{print $NF}' )
#printit 50

case "$2" in

"ext")
fst=$(df -hTP|grep "$1 "|awk '{print $2}')
if [ ! -z "$fst" ] ; then
case "$fst" in
*xfs*|*XFS*) fst="xfs" ; echo "-> xfs fs tespit edildi.."
;;
*ext4*|*EXT4*)fst="ext4" ; echo "ext4 fs tespit edildi.."
;;
*ext3*|EXT3*)fst="ext3" ; echo "ext3 fs tespit edildi.."
;;
*data*)echo "$devdisk formatlanmamis gorunuyor.. !!"
;;
*pv*|*PV*)echo "$devdisk PV diski olarak gorunuyor.. !!"
;;
*)echo "$1 uzerinde filesystem bilgisi tespit edilemedi !! " ; errormsg
;;
esac
else
echo "LVM device ( $vgx-$lvx ) device icin tanimli bir MOUNTPOINT bilgisi bulunamadi !! "
isntmounted "$1"
if [ -z "$fst" ] ; then
echo "LVM device uzerinde filesystem bilgisi tespit edilemedi !! "
#errormsg
fst="NULL"
fi
fi
printit 50
;;

*)echo "filesystem kontrolleri sirasinda bir problem olustu !! "
errormsg
;;
esac
}


resizefsx() {
echo
echo "---------- FileSystem (ext) ----------"
sleep 1
printit 20

mount_tmp=$(df -h |awk -va="$lvmmapperdev" '$1==a')
if [[ -z "$mount_tmp" ]] ; then
echo "[$lvmmapperdev] device icin aktif bir Mount bulunamadi !! "
sleep 1
mountx
sleep 1
fi


case "$fst" in
xfs|XFS) xfs_growfs "$lvmmapperdev" ; errchk $? "xfs_growfs"
;;
ext[3-4]|EXT[3-4]) resize2fs "$lvmmapperdev" ; errchk $? "resize2fs"
;;
"NULL")echo "filesystem bilgisi bulunamadigi icin filesystem EXTEND edilemiyor !! "
;;
*)echo "->> [$fst] desteklenmemekte !! " ; errormsg
;;
esac
printit 30
}


vgxnamechk() {
case "$1" in
*-*)echo "[VG] isimlendirmesi icinde '-' degeri yer almasi LVM device icin tavsiye edilmez !! "
printit 40
vgxtmp=$(echo "$1"|sed 's/-/--/g')
;;
*)vgxtmp="$1"
;;
esac
}

lvxnamechk() {
if [ -z "$1" ] ; then
echo "LVM bilgisi bulunamadi !!! "
errormsg;
fi

case "$1" in
*-*)echo "[LV] isimlendirmesi icinde '-' degeri yer almasi LVM device icin tavsiye edilmez !! "
printit 40
lvxtmp=$(echo "$1"|sed 's/-/--/g')
;;
*)lvxtmp="$1"
;;
esac
}


lv2xchk() {
lv2x=$(lvs|awk -v a="$vgx" '$2==a{print $1}'|grep "$lvx"$ )
if [ -z "$lv2x" ] ; then
[ -z "$vgx" ] && vgx="NULL"
[ -z "$lvx" ] && lvx="NULL"
echo "[$vgx] [VG] icinde [$lvx] isminde bir [LV] device tespit edilemedi !! "
errormsg;
fi
}


lvmdevcheck() {
lvmdev="$1"
if [ ! -b "$lvmdev" ] ; then
echo "[$lvmdev] [LV] device bulunamadi !!! "
echo
echo "-> [LV] device bilgisini elle girmeniz gerekiyor !!! "
sleep 1
errormsg
fi
}


devmapperchk() {
mapperpath="/dev/mapper"
[[ "$pvlayout" == "striped" ]] && vgx=$vgx_striped
vgxnamechk "$vgx" ; lvxnamechk "$lvx"
#lvmmapperdev="$mapperpath/$vgc-$lvc"
lvmmapperdev="$mapperpath/$vgxtmp-$lvxtmp"
lvmdevcheck "$lvmmapperdev"
}


vglvchck() {
vg2x=$(pvs "$1" 2>/dev/null|awk 'NR>1{print $2}')
if [ "$vg2x" != "$2" ] ; then
echo "[$disk] diski uzerinde [$2] isminde bir [VG] bulunamadi !! "
echo
errormsg
else
#echo "[$disk] diski uzerinde [$2] isminde tanimli bir [VG] mevcut [OK] "
vgx=$2
fi
}


fstab_restore() {
cp /etc/fstab.back /etc/fstab ; cpst=$?
[ $cpst -ne 0 ] && echo "fstab dosyasi eski haline donulemedi !! Lutfen [/etc/fstab] dosyasini MANUEL olarak duzeltin !!! "
errchk $cpst "fstab restore"
echo "fstab dosyasi eski haline geri donuldu .. "
}


fstab_check() {
isfstabinready=0
checkl=$(grep $(echo "$mp"|sed 's/[_-]/\./g') /etc/fstab )
if [ ! -z "$checkl" ] ; then
isfstabinready=1
echo
echo "->> fstab icinde onceden olusturulmus benzer isimde MP bilgisi gorunuyor.. "
sleep 1
echo "->> Elle kontrol edilmesi tavsiye olunur !! "
sleep 2
echo "=================="
grep -n $(echo "$mp"|sed 's/[_-]/\./g') /etc/fstab
echo "=================="
sleep 1
fi
}


mpcheck() {
if [ ! -d "/$mp" ] ; then
echo "[/$mp] dizini bulunamadi !! "
sleep 1
mkdir -p -v /$mp
errchk $? "mkdir"
echo "[/$mp] MP dizini olusturuldu [OK] "
else
echo "/$mp dizini zaten var gorunuyor !! kontrol edilmesi gerekebilir.. "
df -h |grep '/${mp}$' &>/dev/null
if [ $? -eq 0 ] ; then
fstab_restore
errormsg
fi
fi
}


mountx() {
#### MP ( MountPoint (mp) bilgisi bulma )
if [ -z "$lvx" ] ; then
echo "[LV] bilgisi bilinmeyen bir sebepten dolayi BOS olarak gorunuyor !! ?? "
errormsg
fi

#echo "$lvx"|grep -i "^lv" &>/dev/null
#mp=$(echo "$lvx"|sed -e 's/^lv[_-]*\|^LV[_-]*//' -e 's/[_-]/\//g')
mp=$(echo "$lvx"|sed -e 's/^lv[_-]*\|^LV[_-]*//')

if [ -z "$mp" ] ; then
#echo "$vgx"|grep -i "^vg" &>/dev/null
#mp=$(echo "$vgx"|sed -e 's/^vg[_-]*\|^VG[_-]*//' -e 's/[_-]/\//g')
mp=$(echo "$vgx"|sed -e 's/^vg[_-]*\|^VG[_-]*//')
fi

if [ -z "$mp" ] ; then
mp="$vgx"
echo "MP bilgisi bulunamadi !! "
errormsg
fi

if [ -z "$mp" ] ; then
mp="$vgx"
echo "MP bilgisi bulunamadi !! "
errormsg
fi


echo "MP bilgisi olarak [/$mp] dizini kullanilacak .. "
sleep 3
mpcheck
printit 30


###FSTAB
cp /etc/fstab /etc/fstab.back
errchk $? "fstab backup"
fstab_check
echo

printit 20
echo "Yeni MP bilgisi '/etc/fstab' a ekleniliyor .. "
printit 20
echo "$lvmmapperdev    /$mp   $fst     defaults        0 0" >> /etc/fstab
errchk $? "fstab mount point(/$mp) ekleme"
echo "Yeni MP bilgisi basariyla '/etc/fstab' a eklenildi [OK] "

###MOUNT
echo
echo "---------- MOUNT (new) ----------"
[ "$isfstabinready" -eq 0 ] && mount -v /$mp || mount -v $lvmmapperdev /$mp
mntst=$?
if [ $mntst -ne 0 ] ; then
df -h /$mp &>/dev/null
if [ $? -ne 0 ] ; then
echo "/$mp mountpoint i MOUNT yapilamadi !! "
fstab_restore
echo "mount islemi sirasinda HATA olustu !!! "
errormsg
fi
else
echo "[/$mp] mountpoint i kullanilarak [$lvmmapperdev] diski MOUNT edildi .. [OK] "
fi


###CHOWN
echo
echo "---------- CHOWN (new) ----------"
#chown -R oracle:dba /$mp ; errchk $? "chown"
#chown -R oracle:oinstall /$mp ; errchk $? "chown"
echo "Mount_Point dizin yetkilendirmesi kullaniciya birakilmistir .. "
#echo "Yetkilendirme tamamlandi .. [OK] "
sleep 1
printit 12
echo
}


formatx() {
#### FORMAT ####
echo
echo "---------- MKFS (new) ----------"
sleep 2
printit 20
case "$fst" in
xfs)  mkfs.xfs  "$lvmmapperdev" ; if [ $? -ne 0 ] ; then umount -v /$mp && mkfs.xfs -f "$lvmmapperdev" ; errchk $? "mkfs.xfs" ; fi
;;
ext4) mkfs.ext4 "$lvmmapperdev" ; if [ $? -ne 0 ] ; then umount -v /$mp && mkfs.ext4 -f "$lvmmapperdev" ; errchk $? "mkfs.ext4" ; fi
;;
ext3) mkfs.ext3 "$lvmmapperdev" ; if [ $? -ne 0 ] ; then umount -v /$mp && mkfs.ext3 -f "$lvmmapperdev" ; errchk $? "mkfs.ext3" ; fi
;;
*) echo "Uygulama Hatasi !! Destek icin 'Yucel Gemici' ile irtibata gecin.."
sleep 1
;;
esac
printit 30
}


fstchk() {
fst=$1
if [ ! $(which mkfs.$fst 2>/dev/null) ] ; then
echo
#echo "[$fst] fs sistem tarafindan desteklenmiyor !!! "
echo "[$fst] bilgisi ile sistem uzerinde eslesen bir [fileystem] destegi bulunamadi !! "
errormsg
else
echo "[$fst] fs sistem tarafindan destekleniyor.. [OK] "
fi
printit 20
}

fschk_new() {
#### FORMAT ####
printit 20
fst="$1"
case "$fst" in
xfs|ext[34])
echo "[$fst] fs uygulama tarafindan destekleniyor.. [OK] "
printit 20
;;
*)
echo "[$fst] fs uygulama tarafindan desteklenmiyor !! Gelistirme icin 'Yucel Gemici' ile irtibate gecin.."
sleep 1
errormsg
;;
esac
}

fschck_limit() {
if [ -z "$1" ] ; then
eho "Bir timeout suresi girilmesi gerekiyor !! "
exit 2
fi
read -t $1 -p "xfs/ext[34] secimlerinden birini yapabilirsiniz ? .. " fst
#sleep $1
#kill $!
#fschk_new
if [ -z "$fst" ] ; then
fst="xfs"
echo -e "\nfst bilgisi Default olarak [$fst] olarak belirlendi .. "
else
echo -e "\nfst bilgisi [$fst] olarak secildi .. "
fi
sleep 1
}


vgxpostchk() {
# vg/lv bilgisi dogru diske mi ait. Son Kontrol...
vglvchck "$devdisk" "$vgx"


#lvmmapperdev in bir LVM device olmasi zorunludur..
devmapperchk;


case $1 in
"ext")
lv2xchk

####################
###Esas islem EXTEND
lvextendx "ext"

###islem sonrasi filesystem islemleri
fschk "$lvmmapperdev" "ext" && [ "$fst" != "NULL" ] && resizepck "$fst" && resizefsx
;;


"new")
##Var olan VG-LV device a YENI BIR DISK EKLEMEK
if [[ ! -z "$vgextendok" ]] && [[ "$vgextendok" -eq 1 ]] && [[ "$lvextendok" -eq 1 ]] ; then
lvextendx "ext"

###islem sonrasi filesystem islemleri
fschk "$lvmmapperdev" "ext" && [ "$fst" != "NULL" ] && resizepck "$fst" && resizefsx

else


##Yeni bir LV device olusturulmussa

###islem sonrasi filesystem islemleri
### ->>> ( EGER ONCEDEN TANIMLI BIR VG BULUNMUYORSA FS ISLEMLERI YAPILAMAZ !!!! )
#echo "[new] parametresi ile FileSystem islemleri desteklenmektedir !! "
#sleep 1
#echo "[$lvmmapperdev] icin filesystem ve mount islemleri elle yapilmalidir.. !! "

### ARTIK new ile Yeni disk icin sadece XFS formati uygulanmaktadir !!! 24.11.2023
if [ ! -z "$lvcreatexx" ] ; then
if [ $lvcreatexx -eq 1 ] ; then
fschk_p_wait=3
fschck_limit $fschk_p_wait

fschk_new "$fst"
fstchk "$fst"
formatx "$fst"

mountx
sleep 1
fi
fi

printit 30
fi


#pvresizex ;
#size bilgisi sadece LV extend icin kullanmaya karar verdim.
#size bilgisi PV size icin kullanilmayacak yani Default olarak disk size in TAMAMI kullanilacak !!
#[ ! -z "$size" ] && pvcreatex $size || pvcreatex


#vglvcheck "$devdisk" "$vgx"


#if [ $ispvs -eq 1 ] ; then
#echo "[$devdisk] diski uzerinde [$vgx] isminde bir [VG] tespit edildi !! "
#fi

echo


##new parametresi ile extend yapilmasin...!!!!
#if [ ! -z "$size" ] ; then
#lvextendx "new" $size
#else
#lvextendx "new"
#fi


## [ext] islemlerinde var olan bir LV device extend edildigi icin mevcut MP uzerinden [fs] tespit edilebiliyor..
## [new] islemlerinde bu islerin elle yapilmasi gerekiyor..
## bunu otomatik yapan [lv_create] scripti var !!

#fschk "$lvmmapperdev" "ext" && [ "$fst" != "NULL" ] && resizepck "$fst" && resizefsx

## parametre new ise filesystem islemleri yapilmiyor simdilik !!
## cunku kullanici fs girisi gerekecek ve uygulamanin degistirilmesi gerekiyor...
#fschk "$lvmmapperdev" "new" && [ "$fst" != "NULL" ] && resizepck "$fst" "new" && resizefsx
;;
esac
}

lvgcount() {
vgcl=$(echo "$1"|awk 'END{print NR}')
}

vgtolv() {
sleep 1
vgtolx=$1
#lvx=$(echo "$vgtolx"|sed 's/vg[-_]*\|VG[-_]*/-\*, -\*, -\*,/'|sed 's/-\*, -\*, -\*,/lv_/')
lvx=$(echo "$vgtolx"|sed 's/vg\|VG\([-_]*\)\(.*\)/lv\1\2/')
if [ -z "$lvx" ] ; then
echo "[$vgtolx] [VG] bilgisinden YENI [LV] device ismi olusturulamadi !! "
errormsg
else
echo "[$vgtolx] [VG] bilgisinden otomatik olarak [$lvx] [LV] ismi olusturuldu .. "
printit 50
islvsok=$(lvs|awk -v a="$lvx" -v b="$vgtolx" 'NR>1&&$1==a&&$2==b{print $1}')


case $2 in
"ext") if [ ! -z "$islvsok" ] ; then
echo "-> [LV] ismi olarak [$islvsok] [LV] bilgisi kullanilacak .. [OK] "
sleep 2

else

lvcount=$(lvs|awk -v a="$vgtolx" '$2==a{x++}END{print x}')
if [ ! -z "$lvcount" ] ; then
if  [ $lvcount -eq 1 ] ; then
lvx=$(lvs|awk -v a="$vgtolx" '$2==a{print $1}')
echo "[LV] bilgisi olarak [$lvx] [LV] bilgisi kullanilacak .. [OK] "
elif [ $lvcount -gt 1 ] ; then
echo "[$vgtolx] [VG] uzerinde birden fazla [ $(echo $(lvs|awk -v a="$vgtolx" '$2==a{print $1}')) ] [LV] device tespit edildi !! "
echo "[LV] bilgisinin parametre olarak girilmesi gerekiyor .. !! "
errormsg
fi
else
echo "[$vgtolx] [VG] uzerinde [LV] bilgisi alinamiyor .. !!! "
errormsg
fi

fi
;;

"new") if [ ! -z "$islvsok" ] ; then
echo "[LV] bilgisi olarak kullanilan [$islvsok] [LV] device zaten mevcut !! "
errormsg
else
echo "[LV] bilgisi olarak [$lvx] [LV] bilgisi kullanilacak .. [OK] "
sleep 2
fi
;;
esac

fi
}


lvguess() {
# VG bilgisi girilmisse LV tahmin edilebilir..
#VG bilgisi girilmisse LV tahmin edilebilir..
pvdiskchk=$1
vgchk=$2

## mpath
#echo "$disk"|grep -e 'dm-' -e mapper >/dev/null
#if [ $? -eq 0 ] ; then
#case "$disk" in
#dm-*)mpathx=$(ls -ltr /dev/mapper/|grep "$disk"$|sed 's/.* \([^ ]*\) ->.*/\1/')
#pvdiskchk="/dev/mapper/$mpathx"
#;;
#*mapper*) 
#mpathx=$(ls -ltr /dev/mapper/|grep " $disk "|sed 's/.* \([^ ]*\) ->.*/\1/')
#pvdiskchk="/dev/mapper/$mpathx"
#;;
#*)echo "Disk bilgisi erisim sirasinda bir sorun olustu !! "
#errormsg
#esac
#fi


vgnamex=$(pvdisplay "$devdisk" 2>/dev/null|awk '/VG Name/{print $3}')

if [ -z "$vgnamex" ] ; then
echo "[$disk] diski uzerinde [$vgchk] isminde bir [VG] bilgisi bulunamadi !!! "
printit 40
pvcreatex
sleep 5
echo "[$disk] diski $vgchk [VG] e dahil ediliyor .. "
printit 40
sleep 2
vgextend $vgchk $diskchk ; errchk $? "vgextend"

else
if [[ "$vgchk" != "$vgnamex" ]] ; then
echo "[$disk] diski uzerinde FARKLI [-> $vgnamex ] bir isime sahip [VG] tespit edildi !!! "
sleep 1
errormsg
else
echo "[$disk] diski uzerinde [-> $vgchk ] ismindeki [VG] tespit edildi ... "
fi
fi


#LV device TAHMIN etme..
#vgc=$(vgs -o +devices|grep "$1"\(|awk '{print $1}')
vgc=$(pvs "$pvdiskchk"|awk 'NR>1{print $2}')
if [ ! -z "$vgc" ] ; then
#lvcl=$(lvs -o +devices|grep "$vgchk"|grep "$pvdiskchk"\(|awk '{a[$1]=x++}END{print x}')
lvcx=$(lvs -o +devices|awk -v a="$vgchk" -v b="$pvdiskchk" '{sub(/\(.*\)/,"",$NF);if(($NF==b)&&($2==a))c[$2"-"$1]}END{for(i in c)print i}')
lvcl=$(echo "$lvcx"|awk 'END{print NR}')
lvcp=$(lvs -o +devices|awk -v a="$vgchk" -v b="$pvdiskchk" '{sub(/\(.*\)/,"",$NF);if(($NF==b)&&($2==a))c[$1]}END{for(i in c)print "("i")"}')
#lvcl=$(lvs -o +devices|awk -v a="$vgchk" -v b="$pvdiskchk" '{sub(/\(.*\)/,"",$NF);if(($NF==b)&&($2!=a))c[$1 $2]}END{for(i in c)print i}'|awk 'END{print NR}')
[ -z "$lvcl" ] && lvcl=0
if [ $lvcl -gt 1 ] ; then
echo "[$disk] disk uzerinde birden fazla (x$lvcl) sayida [LV] device tespit edildi !! "
echo "->" [ $disk: $lvcp ]
echo
##[ext] isleminde birden fazla LV varsa LV tahmini yapilamaz !!!
if [ -z "$lvx" ] ; then
echo "[LV] bilgisi girilmesi gerekli !! "
errormsg
fi

elif [ $lvcl -eq 1 ] ; then
# 1 tane LV device olmasi lazım ve bu extend edilecek..
vgtolv "$vgx" "ext"

#LV device TAHMIN ediliyor..
###lvguess
#lvc=$(lvs -o +devices|grep "$vgchk"|grep "$pvdiskchk"\(|awk '{print $1}')

#if [ ! -z "$lvc" ] ; then
#lvx=$lvc
#echo "->> [$vgchk] [VG] uzerinde [$lvx] [LV] bilgisi tahmin edildi [OK] "
#sleep 1
#else
#echo "[$vgchk] [VG] uzerinde herhangi bir [LV] bilgisi bulunamadi !! "
#errormsg
#fi

fi

else
printit 70
echo "[$pvdiskchk] diski uzerinde herhangi bir [VG] bilgisi bulunamadi !! "
fi
}


vguess() {
diskchk=$1
pvs $diskchk &>/dev/null
if [ $? -ne 0 ] ; then
echo "[$disk] diskin bir PV disk olup olmadigini kontrol edin .. !! "
echo
echo "[$disk] diskin bir PV diski oldugundan eminseniz.. "
echo "(PFree) alanindan bir [LV] icin size(LSize) atamasi yapildigini kontrol edip tekrar calistirin .."
printit 70
[ ! -z "$ext" ] && errormsg
fi


#VG bilgisi girilmemisse VG bilgisi tahmin etme
if [ -z "$2" ] ; then
#vgclc=$(vgs -o +devices|grep "$diskchk"\(|awk '{a[$1]=x++}END{print x}')

##Ayni disk birden fazla VG ??##
vgclc=$(vgs -o +devices |awk 'NR>1{print $1 FS $NF}'|grep "$diskchk"\(|awk '{if(!a[$1])a[$1]++}END{for(i in a)x+=a[i];print x}')
[ -z "$vgclc" ] && vgclc=$(pvs -o +devices "$diskchk" |awk 'NR>1{a[$2]=x++}END{print x}')
[ -z "$vgclc" ] && vgclc=0

if [ "$vgclc" -eq 0 ] ; then
echo "[$disk] diski uzerinden bir [VG] bilgisi tahmin edilemedi !! "
echo "[$disk] diski uzerinde gecerli en az bir [LV] device oldugudan emin olun !! "

#vgx=$(pvs|awk -v a="$diskchk" '$1==a{b[$2]}END{for(i in b);print i}')
vgx=$(pvs "$diskchk"|awk '/VG Name/{if($NF!="Name")print $NF}')
[[ ! -z "$vgx" ]] && lvxc=$(lvs|awk -v a="$vgx" '$2==a{x++}END{if(!x){x=0;print x}}')
[[ ! -z "$vgx" ]] && echo "[$disk] diski uzerindeki [$vgx] [VG] uzerinde yer alan [LV] sayisi -> '$lvxc' "
echo
errormsg
elif [ $vgclc -gt 1 ] ; then
echo "[$disk] diski uzerinde birden fazla [VG] bulundu. LVM konfigurasyonunda yada uygulamada bir sorun olabilir !! "
errormsg
elif [ $vgclc -eq 1 ] ; then
#vgdiskchk=$(pvs "$diskchk"|awk 'NR>1{print $2}')
vgdiskchk=$(pvdisplay "$diskchk"|sed -n '/VG Name/s/  VG Name//p'|sed 's/ *//g')
if [ -z "$vgdiskchk" ] ; then
echo "[VG] bilgisi tespit edilemedi !!! "
errormsg
fi
vgx=$vgdiskchk
echo "->> [$disk] uzerinde [VG] bilgisi [$vgdiskchk] olarak tespit edildi [OK] "
echo
sleep 3
echo "[VG] bilgisi [$vgdiskchk] ile devam ediliyor ... "
sleep 3
echo -e "-> [$vgdiskchk] icin yapilacak islemi kesmek icin 'Ctrl-C' tuslarini kullanabilirsiniz !! \n"
sleep 2
echo -e "-> [$vgdiskchk] icin yapilacak islemi kesmek icin 'Ctrl-C' tuslarini kullanabilirsiniz !!! \n"
sleep 1
echo

#LV tahmin
#lvguess $diskchk $vgx
sleep 1
fi

else
[ -z "$lvx" ] && lvguess $diskchk $vgx
fi
}



islvs() {
islvsalready=0
if [ ! -z "$1" ] ; then
#lvs|awk 'NR>1'|grep "$1 " &>/dev/null
islvschk=$(lvs|awk -v a="$lvx" -v b="$vgx" 'NR>1&&$1==a&&$2==b{print $1}')
if [ ! -z "$islvschk" ] ; then
echo "->> [$lvx] isminde zaten bir [LV] device bulunuyor !! "
sleep 1
printit 20
sleep 1
echo "->> [LV] device bilgisi olarak [$lvx] ismi kullanilacak [INFO] "
sleep 1
islvsalready=1
fi
else
echo "[LV] isimlendirmede bir sorun olustu [->islvs] !! "
errormsg
fi
}


lvcreatex() {
###lvm device create ediliyor..
echo
sleep 1
islvs "$lvx"
sleep 2
printit 50

[ -z "$vgextendxx" ] && vgextendxx=0
if [ $vgextendxx -eq 0 ] ; then
if [ $islvsalready -eq 0 ] ; then
echo "[LV] device olusturma islemlerine devam ediliyor .... "
sleep 2

pvresizex
freelvchk

echo "->> [$lvx] isminde YENI bir [LV] device olusturulacaktir ... "
sleep 3

pesizechk

#####Free LV alanı , istenilen size alanini karsiliyor mu ? ######

if [ ! -z "$size" ] ; then
lvfreesizechk "$sizeusergib" "$freelvgib2"
if [ -z "$lvsizechk" ] ; then
echo "[LV-Create] islemi icin [$vgx] [VG] uzerinde yeterli buyuklukte alan bulunmuyor -> [ $freelvgib Gib < $sizeusergibshow Gib ] !! "
#echo "[LV-Create] islemi icin [$vgx] [VG] uzerinde yeterli buyuklukte alan bulunmuyor -> [ $freelvgib Gib < $sizec ] !! "
printit 50

if [[ "$growpartprint" -eq 1 ]] ; then
echo
echo "[growpart $grow_devdisk $diskprt] komutunu calistirmaniz gerekiyor olabilir ... "
sleep 2
echo
echo "[growpart] uygulamasi kullanilamiyor ise [fdisk] komutu ile [$disk] partitionu silip tekrardan olusturmaniz gerekiyor olabilir .... "
echo
sleep 2
fi

errormsg
else
lvcreate -L ${sizec} -n $lvx $vgx
lvcreate_st=$?
sleep 1
fi

else
##Size degeri bossa
lvcreate -l +100%FREE -n $lvx $vgx
lvcreate_st=$?
sleep 1
fi


lvcreatexx=0
if [ $lvcreate_st -eq 0 ] ; then
[ ! -z "$freelvpe" ] && sizec="$freelvpe"
[ -z "$size" ] && usedlvsize="$freelvgib Gib" || usedlvsize="$sizeusergibshow Gib"
printit 50
echo "[$lvx] isminde YENI bir [LV] device [+$usedlvsize ] kadar alan kullanilarak olusturuldu .. [OK] "
sleep 2
lvcreatexx=1
printit 30
echo "[LV] device tanimlama islemleri BASARILI tamamlandi [OK] "
sleep 1
else
echo "[$lvx] isimli [LV] device olusturulurken bir sorun olustu !! "
errormsg;
fi

else
echo "[$lvx] isminde zaten mevcut bir [LV] device bulunuyor !! "
errormsg
fi

else
echo "Daha onceden [vgextend] islemi yapildigi icin bu adimda yeni bir LV olusturulmasi desteklenmiyor !! "
recomm=$(for((i=1;i<=$((cc-1));i++));do echo -n "${@: $i:1} "; done)
echo "Lutfen uygulamayi ayni degerlerle ve [ext] parametresi ile tekrar calistirin .. -> $recomm"
sleep 1
exit 0
#errormsg
fi
}

lvchecklvs() {
isvgx="$1"
if [ -z "$2" ] ; then
islvsx=$(lvs|awk -v a="$isvgx" '$2==a{print $1}' 2>/dev/null)
else
islvx="$2"
islvsx=$(lvs|awk -v a="$isvgx" -v b="$islvx" '$2==a&&$1==b{print $1}' 2>/dev/null)
fi
}

lvnamerecreate() {
isvgx="$1"

case "$isvgx" in
*[-/]*)echo "[LV] isimlendirmesi icinde '[-/]' gibi karakterlerin kullanilmasi tavsiye edilmez !! "
for i in - / ; do
echo "$isvgx"| grep -o .|grep "^${i}$" &>/dev/null
echo "'$i' degeri '_' olarak duzeltiliyor !! "
sleep 1
if [ $? -eq 0 ] ; then
lvx=$(echo "$isvgx"|sed 's/vg[-_]*\|VG[-_]*/-\*, -\*, -\*,/'|sed 's/-\*, -\*, -\*,/lv_/'|sed "s/^[$i]//g"|sed 's/^[/-]//g')
fi
done
;;
*)lvx="$isvgx"
;;
esac

if [ -z "$lvx" ] ; then
echo "[LV] yeniden isimlendirme sirasinda bir sorun olustu !! "
errormsg
else
lvx=$(echo "$isvgx"|sed 's/vg\|VG\|vG\|Vg/lv/g')
fi

echo
echo "[LV] bilgisi olarak [$lvx] ismi kullanilacak !!! "
}


lvnamecreate() {
vgx=$1

case $2 in

"ext")lvchecklvs $vgx
if [ ! -z "$islvsx" ] ; then
islvsxcl=$(echo "$islvsx"|awk 'END{print NR}')
if [ $islvsxcl -gt 1 ] ; then
echo "[$isvgx] [VG] uzerinde birden fazla [LV] device oldugu icin [LV] bilgisinin parametre olarak girilmesi gerekiyor.. !! "
errormsg
elif [ $islvsxcl -eq 1 ] ; then
## 1 tane LV varsa
lvx="$islvsx"
echo "[LV] bilgisi [$lvx] olarak bulundu !! "
sleep 2
fi
else
echo "[$isvgx] uzerinde tanimli bir [LV] bulunamadi !! "
sleep 1
vgtolv "$vgx" "ext"
fi
;;


"new")
vgextendxx=0
lvnamerecreate $vgx
if [ ! -z "$lvx" ] ; then
lvchecklvs "$vgx" "$lvx"
if [ ! -z "$islvsx" ] ; then
[[ "$lastp" == "new" ]] && echo "-> [$isvgx] [VG] uzerinde [$lvx] isminde zaten bir [LV] device bulunuyor [FAIL] " && errormsg
[[ "$lastp" == "ext" ]] && echo "-> [$isvgx] [VG] uzerinde [$lvx] isminde [LV] device tespit edildi [OK] "
printit 30
sleep 2
echo
### new parametresi ile disk extend islemleri desteklenmiyor !!!
#echo "-> [vgextend] islemleri baslatilacak .. "
#sleep 2
#vgextendx "$vgx" "$devdisk"
#vgextendxx=1
#errormsg
fi
fi
;;
esac
}


lvrecheck() {
##lvx LV kontrolleri
lvx="$1"
lvc=$(lvs|awk -v a="$lvx" -v b="$vgx" '$1==a&&$2==b{print $1}')
if [ -z "$lvc" ] ; then

case $3 in
"ext")ext="1"
vguess "$devdisk" "$vgx"
lvx=$(echo "$lvx"|sed 's/[-]\+/-/g')
#lvc=$(lvs |grep "$lvx "|awk '{print $1}')
lvc=$(lvs|awk -v a="$lvx" -v b="$vgx" '$1==a&&$2==b{print $1}')
if [ -z "$lvc" ] ; then
echo "[$vgx] [VG] uzerinde [$lvx] isminde bir [LV] device bulunamadi !! "
#parametre new degil ve lvx device yoksa
errormsg
fi
;;

"new")
lvcreatexx=0
lvcreatex #"$lvx" "$vgx" "new"
;;
esac

else

###lvm device varsa birden fazla disk icin kullaniliyor olabilir mi ( pvcreate --physicalsize ? )
lvgcount $lvc
if [ "$vgcl" -gt 1 ] ; then
echo "[$1] ismiyle eslesen birden fazla [LV] device bulundu.. !! "
errormsg
fi

###LV device zaten mevcutsa"
if [ "$vgcl" -eq 1 ] ; then

lvclstchk=$(lvs|awk -v a="$lvx" 'a==$1{print $1}')
if [ -z "$lvclstchk" ] ; then
lvclstchk=$(lvs|awk -v a="$lvc" 'a==$1{print $1}')
if [ ! -z "$lvclstchk" ] ; then
lvx="$lvc"
else
echo "[LV] device ismi tespit edilirken bir sorun olustu !!! "
errormsg
fi
fi

case $3 in
"ext")
printit 40
echo "[$vgx] [VG] icin [$lvx] ismindeki [LV] device extend edilecek .. "
echo
sleep 3
;;

"new")
printit 40
echo "->> [$vgx] [VG] icin [$lvx] isminde bir [LV] device zaten mevcut durumda !! "
echo
printit 40
sleep 3

# new ile sadece yeni VG/LV ler olusturulabilir. extend islemleri icin ext kullanilmasi zorunlu !!
if [ ! -z $vgextendok ] && [ $vgextendok -eq 1 ] ; then
echo "-> [$vgx] [VG] icin [$lvx] ismindeki [LV] device extend edilecek (new) .. !! "
lvextendok=1
else
lvextendok=0

echo "-> [$vgx] [VG] extend islemleri sadece [ext] parametresi ile yapildigi icin [$lvx] ismindeki [LV] device extend edilemiyor .. !!! "
sleep 2
echo "-> [$vgx-$lvx] device extend islemleri icin [ext] parametresi kullanarak lutfen tekrar calistirin .. "
echo
[[ -z "$lvx" ]] && LV=LV || LV=$lvx
echo "[$0 $disk $vgx $LV ext] komutu ile ilgili [VG] extend edebilirsiniz .. "
printit 50
sleep 2
errormsg
fi
#islem sonuc herhangi bir degisiklik olmadiginin gorulmesi icin HATA verdirilmiyor ??
#errormsg
;;
esac

fi
fi
}

######LV check
lvcheck() {
##Bu asamaya kadar "vgx" bilgisinin bulunmus olmasi gerekli !!
if [ -z "$vgx" ] ; then
echo "[VG] bilgisi bulunamadigi icin islemlere devam edilemiyor !! "
errormsg
fi

lvxx=$1
###VG isminden yeni bir LVM ismi otomatik belirlenir..
if [ -z "$lvxx" ] ; then
## VG bilgisi olmak zorunda !!
if [ ! -z "$vgx" ] ; then
#vgf=$(echo $vgx|sed 's/^vg[-_]*\|VG[-_]*//')
#lvx=$(echo "lv-${vgf}")

echo "$vgx"|grep 'vg\|VG' &>/dev/null
if [ $? -eq 0 ] ; then
echo
printit 30
echo "[LV] bilgisi belirtilmedigi icin [VG->$vgx] isminden [LV] isim bilgisi tahmin edilecektir !! "
[ "$2" == "new" ] && lvnamecreate "$vgx" "new" || lvnamecreate "$vgx" "ext"
echo
else
#echo Eger VG isminde VG/vg bilgileri gecmiyorsa LV ismi ile VG ismi AYNI olabilir..
echo "[LV] bilgisi belirtilmedigi icin otomatik olarak [VG->$vgx] ismi kullanilacaktir !! "
lvx=$vgx
fi
lvrecheck $lvx $vgx "$2"
sleep 2

fi

else
##LV ismi belli ise
lvrecheck $lvxx $vgx "$2"
fi
}

vgnamechk() {
vgnamenewx=0
vgxtemp="$1"

case "$vgxtemp" in
*[-/]*)echo "[VG] isimlendirmesi icinde '[-/]' gibi karakterlerin kullanilmasi tavsiye edilmez !! "
for i in - / ; do
echo "$vgxtemp"| grep -o .|grep "^${i}$" &>/dev/null
if [ $? -eq 0 ] ; then
echo "$i degeri '_' olarak duzeltiliyor !! "
vgnamenew=$(echo "$vgxtemp"|sed 's/vg[-_]*\|VG[-_]*/-\*, -\*, -\*,/'|sed 's/-\*, -\*, -\*,/vg_/'|sed "s/^[$i]//g"|sed 's/^[/-]//g')
fi
done
;;
*)vgnamenew="$vgx"
;;
esac

if [ ! -z "$vgnamenew" ] ; then
vgx="$vgnamenew"
sleep 2
else
echo "[VG] isimlendirme sirasinda bir sorun olustu !! "
errormsg
fi

echo -e "\n[VG] bilgisi olarak [$vgx] ismi kullanilacak !! "
}


######VG check
vgcheck() {

vgtmpx="$1"
vgc=$(vgs "$vgtmpx" 2>/dev/null|awk '{print $1}')

##VG bilgisi yok
if [ -z "$vgc" ] ; then

case "$2" in

"ext")
echo "[$disk] diski uzerinde [$vgtmpx] isminde bir [VG] bilgisi bulunamadi !!! "
errormsg

##PV disk kontrol
#pvscheck "ext"
;;

"new")echo "[$disk] diski uzerinde [$vgtmpx] isminde bir [VG] bilgisi bulunamadi !! "
vgnamechk "$vgtmpx"
echo "->> ['$vgx'] isminde YENI bir [VG] olusturulacaktir [INFO] "
sleep 1
echo "[VG] bilgisi ismi icinde "[lv_]/[LV_]" bilgilerinin yer almasi tavsiye edilmez !!! "
sleep 3
#echo "[VG] bilgisi ismi icinde "[lv_]/[LV_]" bilgilerinin yer almasi tavsiye edilmez !!! "
echo
echo -e "-> [vgcreate] islemini kesmek icin 'Ctrl-C' tuslarini kullanabilirsiniz !! \n"
sleep 3
printit 50
####

##PV disk kontrol
#pvscheck "new"

###VG create
echo -e "-> [vgcreate] islemini kesmek icin 'Ctrl-C' tuslarini kullanabilirsiniz !! \n"
printit 30
sleep 3
[ ! -z "$size" ] && echo "->> [VG] olusturulurken [->size] bilgisi kullanilmasi desteklenmiyor !! " && echo && sleep 2
vgcreate "$vgx" "$devdisk" ; vgcreate_st=$? ; errchk $vgcreate_st "vgcreate"
if [ $vgcreate_st -eq 0 ] ; then
echo "['$vgx'] isminde YENI bir [VG] olusturuldu .. [OK] "
#artik YENI disk alani Free VG alanina dahil edildi..
sleep 1
else
echo "[$vgx] isimli [VG] olusturulurken bir sorun olustu !! "
errormsg;
fi
;;
esac


else
##VG bilgisi varsa

##ayni VG birden fazla disk uzerinde bilgilendirmesi
vgdsks=$(pvs 2>/dev/null|awk -va="$vgx" '$2==a'|awk 'END{print NR}')
if [[ "$vgdsks" -gt 1 ]] ; then
pvsdsks=$(pvs 2>/dev/null|grep "$vgx"|awk '{sub("/dev/","",$1);sub("mapper/","",$1);print $1}')
echo "[$vgx] ismindeki [VG] bilgisi birden fazla disk "[ $pvsdsks ]" uzerinde tanimli gorunuyor .. "
sleep 1
fi

case "$2" in
"ext")

### LV parametresi yoksa
if [ -z "$lvx" ] ; then
echo "[$vgx] ismindeki [VG] kullanilarak [ext/extend] islemlerine devam edilecek ... "
printit 40
echo
echo -e "-> [lvextend] islemlerini kesmek icin 'Ctrl-C' tuslarini kullanabilirsiniz !! \n"
sleep 3
echo
#echovgchk=$(pvs "$diskchk"|awk 'NR>1{print $2}')


###VG extend islemini DISABLE ediyorum....26-08-2023
#vgextendx "$vgx" "$devdisk"
#artik YENI disk alani Free VG alanina dahil edildi..
#errormsg;
fi
;;


"new") ##VG isimleri uniq olmalidir !!
##Sadece vgextend yapilmasi gerekir aslinda..
#vgc=$(vgs -o +devices $vgx|awk 'END{print $1}')
isvgc=$(vgs -o +devices |awk 'NR>1{print $1 FS $NF}'|grep $1)


#Yeni disk ise lvcreate yapilmali !!
if [ -z "$isvgc" ] ; then

##vgextend iptal edildi.
#vgextendx "$vgx" "$devdisk"

echo "-> [$vgx] ismindeki [VG] kullanilarak [new(create)] islemlerine devam edilecek ... "
vgtmp=$1
vgcx=$(vgs "$vgtmp"|awk 'NR>1{print $3}')

case $vgcx in
##VG icinde LV yoksa
0)
if [ -z "$lvx" ] ; then
vgtolv "$vgx" "new"
if [ ! -z "$lvx" ] ; then
echo "[$vgtmp] [VG] uzerinde [$lvx] isminde YENI bir [LV] device olusturulacaktir !! "
echo
echo -e "-> [lvcreate] islemini kesmek icin 'Ctrl-C' tuslarini kullanabilirsiniz !! \n"
sleep 3
else
echo "[$vgtmp] [VG] bilgisi kuilanilarak uygun bir [LV] ismi bulunamadi !! "
errormsg
fi
###??
#lvcreatex
fi
;;

*)
lvxx=$(lvs 2>/dev/null|awk -v a="$vgtmp" '$2==a{print $1}')
echo "[$vgtmp] [VG] uzerinde tanimli [LV] device(lar) tespit edildi -> " [ $lvxx ]
if [ -z "$lvx" ] ; then
vgtolv "$vgtmp" "new"
if [ ! -z "$lvx" ] ; then
islvsok=$(lvs |awk -v a="$vgtmp" '$2==a{print $1}'|while read lvsx ; do awk -v a="$lvsx" -v b="$lvx" 'BEGIN{if(a==b)print "OK"}' ; done)
if [ -z "$islvsok" ] ; then
echo "[$vgtmp] [VG] uzerinde [$lvx] isminde YENI bir [LV] device olusturulacaktir !! "
vgtolv "$vgx" "new"
echo -e "-> [lvcreate] islemi kesmek icin 'Ctrl-C' tuslarini kullanabilirsiniz !! \n"
sleep 2
echo
lvcreatex
else
echo "->> [$vgtmp] [VG] uzerinde [$lvx] isminde zaten bir [LV] device bulunmaktadir !! "
#errormsg
fi

else
echo "[$vgtmp] [VG] bilgisi kuilanilarak uygun bir [LV] ismi bulunamadi !! "
errormsg
fi
fi
;;
esac

printit 30

vgextendxx=0

else
diskvgx=$(pvs|awk -v a="$vgx" -v b="$disk" '$2==a&&$1!="/dev/"b{sub("/dev/","",$1);print $1}' ORS=" " )
diskvgx2=$(pvs|awk -v a="$vgx" -v b="$disk" '$2==a&&$1=="/dev/"b{sub("/dev/","",$1);print $1}' ORS=" " )
if [ ! -z "$diskvgx" ] && [ -z "$diskvgx2" ] ; then
echo "[$vgx] [VG] bilgisine ait disk(ler) [ -> $diskvgx] "
echo
printit 30

echo "-> [vgextend] islemleri baslatilacak ... "
sleep 2
vgextendx "$vgx" "$devdisk"
vgextendxx=1
fi

#errormsg
fi

;;
esac

fi
}

extnewmsg() {
if [ -z "$size" ] ; then
echo "Son parametre 'ext/new' olarak belirtilmelidir... !! "
else
echo "Size('s=xx') bilgisinden onceki parametre 'ext/new' olarak belirtilmelidir... !! "
fi
errormsg
}

pvfstchck() {
ispvalready=0
pvdisk=$(pvs 2>/dev/null|grep "$devdisk" |awk '{print $1}')
if [ ! -z "$pvdisk" ] ; then
pvdiskl=$(echo "$pvdisk"|awk 'END{print NR}')
if [ $pvdiskl -eq 1 ] ; then
if [[ "$pvdisk" != "$devdisk" ]] ; then
ispvalready=1
pvdisknodev=$(echo "$pvdisk"|sed 's;/dev/;;'|sed 's;mapper/;;')
echo "[$disk] e ait farkli bir partition [$pvdisknodev] uzerinde bir [PV] yapisi bulunuyor.. !! "
errormsg
fi
fi
if [ $pvdiskl -gt 1 ] ; then
ispvalready=1
pvdiska=$(echo "$pvdisk"|awk -v a="$devdisk" '$1!=a{print ++x}')
#pvdiska=$(pvs 2>/dev/null|grep "$devdisk" |awk '{print $1}'|awk -v a="$devdisk" '$1==a{print ++x}')
[ $pvdiska -gt 1 ] && msg2="lar"
echo "[$devdisk] e ait farkli partition${msg2} uzerinde" [$pvdisk] "zaten bir [PV] yapisi bulunuyor.. !! "
errormsg
fi
fi
}


diskchck() {
#ls /dev/sd*|grep $2 >/dev/null
#if [ $? -ne 0 ] ; then
#echo "2. parametre olarak sistemde gecerli bir disk device ismi belirtmeniz gerekiyor.. !! "
#errormsg
#fi

## mpath
#echo "$disk"|grep 'mpath' >/dev/null
#if [ $? -eq 0 ] ; then
#echo "Sistemde gecerli bir disk device ismi belirtmeniz gerekiyor.. !! "
#echo "[mpath] disk isimleri kullanilamaz !!! "
#errormsg
#fi

## scsi
diskother="nok"

## non-scsi
## nvme
#echo "$disk"|egrep '^sd|^dm-|mpath*' >/dev/null
echo "$disk"|grep 'nvme' &>/dev/null
if [ $? -eq 0 ] ; then
devdisk="/dev/$disk"
sleep 3

echo "Standart Scsi disk device dan farkli bir device bilgisi kullaniliyor olabilir !! "
echo "$disk"|grep -q 'p[0-9]*$' && isdisk=part || isdisk=disk
diskdx=$(echo "$disk"|sed 's/p*[0-9]*$//'|sed 's;/dev/;;')

lshw &>/dev/null
if [ $? -eq 0 ] ; then
printit 40
lshw -class disk | awk -v dev="$diskdx" '{for(i=1;i<=NF;i++)if($i~dev){c="ok";print $i }}END{if(!c)print dev " bir disk device olarak tespit edilemedi !!"}' RS='  [*]-' FS="\n\n"
printit 40
fi
diskother="ok"
fi


if [ ! -b "$devdisk" ] ; then
echo "[$devdisk] isminde bir disk device bulunamadi !! "
echo "[$disk] diski icin KERNEL seviyesinde tarama yapiliyor .. "
sleep 2
pvscanx
if [ ! -b "$devdisk" ] ; then
echo "Tarama sonrasi [$devdisk] isminde bir disk device tespit edilemedi !!! "
errormsg
else
echo "Tarama sonrasi [$devdisk] isminde disk device bulundu [OK] "
sleep 1
fi
fi

###pvs check###
pvfstchck;

if [ $lsblkok -eq 0 ] ; then
echo "[$disk] icin [lsblk] gosterimi YAPILAMIYOR !! "
echo
echo "Kullanilan DISK/PART [->$disk] bilgisi .. "
printit 30
sleep 1
fdiskchk=$(which fdisk 2>/dev/null)
[ ! -z "$fdiskchk" ] && fdisk -l "$devdisk"
printit 30
echo

echo -e "[LV] extend/create islemlerini kesmek icin 'Ctrl-C' tuslarini kullanabilirsiniz !! \n"
sleep 3
printit 30
sleep 2
else
echo
echo "[LV] islemlerinde kullanilacak DISK bilgisi ... "
printit 30
lsblk "$devdisk"
printit 30
sleep 1
echo
echo "[LV] extend/create islemlerine devam ediliyor ... "
sleep 1
printit 50
echo
fi
}


dskchk() {
if [ -z "$1" ] ; then
echo "1. parametre olarak disk (or->[sdb]) bilgisi girilmesi zorunludur.. !! "
errormsg
fi
}

### Online resizing yapildigini varsayiyorum ###
#chkmounted=$(lsblk -o NAME,MOUNTPOINT "$devdisk"|awk 'NR>1&&$2!=""{print $2}')
#if [ ! -z "$chkmounted" ] ; then
#printit 30
#echo "[MOUNT] lu device lar [FORCE] edilemez !!! "
#echo "islemlerin MANUEL yapilmasi gerekir !!! "
#printit 30
#for i in $chkmounted ; do
#df -hT $i
#done
#printit 30
#lsblk -o NAME,MOUNTPOINT $devdisk
#printit 30
#errormsg
#fi

### kernel newsize ###
#kernelchk=$(uname -r|grep "el[7-8]")
#if [ -z "$kernelchk" ] ; then
#echo 1 > /sys/block/$disk/device/rescan
#fi


completed() {
echo
echo "ISLEM SONRASI"
process_check
echo
echo "====ISLEM TAMAMLANDI===="
echo
}

paramfail() {
echo "Uygulamaya verilen parametreler YANLIS gibi gorunuyor !! "
if [ -z "$sizec" ] ; then
#echo "-> $1 parametre kullaniminda Size('s=xx') bilgisi son parametre olarak verilebilir .. "
sleep 1
echo "Size('s=xx') bilgisi verilmeden $1 adet parametre ile uygulama calistirilamaz !! "
echo
fi
errormsg
}


##############parametre kontroleri##############
paramcheck() {
####parametre sayisi max : 5 / min : 2
paramc=$#
case $paramc in


#####5
5) if [ ! -z "$size" ] ; then
vgx="$2";lvx="$3"
case "$4" in
"ext") pvscheck "ext" ; vgcheck "$vgx" "ext" ; lvcheck "$lvx" "ext" ; vgxpostchk "ext"
;;
"new") pvscheck "new" ; vgscheck "$vgx" new ; vgcheck "$vgx" "new" ; lvcheck "$lvx" "new" ; vgxpostchk "new"
;;
*)extnewmsg;
;;
esac

else
[[ ! $stripe_param -eq 1 ]] && paramfail $#
fi
;;


#####4
4) if [ ! -z "$size" ] ; then
vgx="$2";
#lvx=$3
###lv bilgisini bulmaya calisalim..

case $3 in
"ext") pvscheck "ext" ; vgcheck "$vgx" "ext" ; lvguess "$devdisk" "$vgx" ; lvcheck "$lvx" "ext" ; vgxpostchk "ext"
;;
"new") pvscheck "new" ; vgscheck "$vgx" "new" ; vgcheck "$vgx" "new" ; lvcheck "$lvx" "new" ; vgxpostchk "new"
;;
*)pvscheck "ext" ; lvx=$3 ; lvcheck "$lvx" "ext"
echo -e "\n->> islem tipi belirtilmedigi icin Default olarak [ext] bilgisi kullanilacak !!" ;
sleep 2
echo
vgxpostchk "ext"
;;

esac

else
vgx="$2";lvx="$3"

case "$4" in
"ext") pvscheck "ext" ; vgcheck "$vgx" "ext" ; lvcheck "$lvx" "ext" ; vgxpostchk "ext"
;;
"new") pvscheck "new" ; vgscheck "$vgx" "new" ; vgcheck "$vgx" "new" ; lvcheck "$lvx" "new" ; vgxpostchk "new"
;;
*)extnewmsg;
;;
esac
fi
;;


#####3
3) if [ ! -z "$size" ] ; then
###VG icinde 1 tane LV varsa "ext" icin calisir
###bash lvme sdd ext s=10g
case "$2" in
"ext")ext="1"
pvscheck "ext"
vguess "$devdisk"
;;
"new")
echo "[new] parametresi kullanilamaz !! "
echo "[ext] olarak islemlere devam ediliyor .. "
pvscheck "ext"
sleep 2
vgscheck "$vgx" "new"
vguess "$devdisk"
;;
*)
###bash lvme sdd vg-testx s=10g
vgx=$2 ; vgcheck "$vgx" "ext"
vguess "$devdisk" "$vgx"
;;
esac

[ -z "$lvx" ] && lvguess "$devdisk" "$vgx"
##Default olarak ext parametresi calisir.
lvcheck "$lvx" "ext"
pvscheck "ext"
vgxpostchk "ext"


###size bilgisi yoksa
else
###bash lvme sdd vg-testx new
vgx="$2";
#LV bilgisi girilmis degil !!

case $3 in
"ext") pvscheck "ext" ; vgcheck "$vgx" "ext" ; lvguess "$devdisk" "$vgx" ; lvcheck "$lvx" "ext" ; vgxpostchk "ext"
;;
"new") pvscheck "new" ; vgscheck "$vgx" "new" ; vgcheck "$vgx" "new" ; lvcheck "$lvx" "new" ; vgxpostchk "new"
;;
*)extnewmsg;
;;
esac
fi
;;


#####2
2)if [ "$2" == "ext" ] ; then
sleep 3
ext="1"
pvscheck "ext"
vguess "$devdisk" "$vgx"
vgxpostchk "ext"

else
vgx="$2"
pvscheck "ext"
echo "Girilen parametreler eksik veya HATALI !! [ parametre sayisi : $paramc ] "
if [[ "${@: -1}" != "ext" ]] || [[ "${@: -1}" != "new" ]] ; then
echo
echo "->> Son parametre olarak 'ext' yada 'new' degerleri girilmeli !! "
echo
sleep 1
fi
vgstmp=$(pvs|awk -v a="$devdisk" '$1==a{print $2}')
if [ ! -z "$vgstmp" ] ; then
[ "$vgstmp" == "lvm2" ] && echo "[$disk] diski uzerinde tanimli bir [VG] bulunamadi !! " && echo "[./$0 $disk vg_VGxxx new] komutu ile yeni bir [VG] olusturabilirsiniz.. " && errormsg
echo "2 parametre kullanilarak sadece [$disk] disk uzerinde tanimli [$vgstmp] [VG] icin [ext] parametresi ile islem yapilabilir -> [ ./$0 $1 ext ] "
else
echo "2 parametre kullanilarak sadece [$disk] diski uzerinde tanimli [VG] icin [ext] parametresi ile islem yapilabilir -> [ ./$0 $1 ext ] "
echo "-> [$disk] diski uzerinde tanimli bir [VG] bilgisi tespit edilemedi !! "
errormsg
fi
errormsg
fi
;;


#####1
1)echo "Parametre sayisi 2 den az olamaz.. -> [VG] bilgisi girdiginizden emin olun !! "
errormsg
;;


#####?
*)
#if [ $stripe_param -ne 1 ] ; then
echo "-> [linear] layout yapida [VG] extend/create islemleri icin girilen parametreler hatali veya max parametre sayisi asilmis !! "
if [ $# -gt 5 ] ; then echo "Parametre sayisi 5 den fazla olamaz .. !! "
echo "* max verilebilecek parametre sayisi : 5 ;;; -> Girilen parametre sayisi : $paramc "
fi
errormsg
#fi
;;

esac

completed
}


issize() {
####s=size kontrolu - size bilgisi sadece SON parametre icinde aranir !! ####
for last; do true; done
sizeprmchk $last $@
}


justdoit() {
if [[ $stripe_param -eq 1 ]] ; then
completed       	
else
if [ ! -z "$1" ] ; then
issize $@
paramcheck $@
else
echo "1. parametre olarak 'Disk' bilgisi girildiginden emin olun !! "
errormsg
fi
fi
}


### justdoit() @unix.com ygemici ###
firstcheck() {
# islem sirasinda tekrar disk device kontrol edilmesinde fayda var
disk=$(echo "$1"|sed 's/.*\///')
dskchk "$disk"

echo "$1"|grep 'mapper' &>/dev/null
if [ $? -eq 0 ] ; then
devdisk="/dev/mapper/$disk"
else
devdisk="/dev/$disk"
[[ ! -b "$devdisk" ]] && devdisk="/dev/mapper/$disk"
fi

if [ ! -b "$devdisk" ] ; then
echo "[$disk] parametresi gecerli bir disk device olarak gorunmuyor !!! "
echo
devdisk=""
if [ "$2" != "stripe" ] ; then
errormsg
else
vgsfrechk=$(vgs "$vgx" 2>/dev/null|awk -v a="$vgx" 'NR>1{if(a==$1)print "OK"}')
if [ ! -z "$vgsfrechk" ] ; then
printit 30
echo "-> [striped] layout kontrolu icin verilen parametre degeri [$vgx] aktif bir [VG] olarak tespit edildi [OK] "
else
printit 30
echo "-> [striped] layout kontrolu icin verilen parametre degeri [$vgx] gecerli bir [VG] olarak tespit edilemedi !!! "
sleep 1
#errormsg
fi
printit 30
fi
else
printit 30
[[ "$2" == "stripe" ]] && echo "-> [striped] layout kontrolu icin verilen parametre degeri [$disk] bir disk device olarak tespit edildi {INFO] "
[[ "$2" != "stripe" ]] && echo "-> [$disk] parametresi gecerli bir disk device olarak gorunuyor [OK] " || \
echo "-> [$disk] parametresi gecerli bir disk device olarak gorunuyor [OK-stripe]"
sleep 1
printit 30
fi
echo

lsblkchk;
#diskchck "$disk" "$devdisk"
diskchck #"$disk" "$devdisk"
}



stripecheck() {
stripedsk="$1"
isstriped=$(lvs -o+lv_layout,stripes,devices|awk -v a="$vgx" '$2==a'|grep -w "$stripedsk")
if [ ! -z "$isstriped" ] ; then
#echo "[VG-striped] yapidaki diskler extend edilemez !!! "
echo "->> [$stripedsk] diski zaten [$vgx] icinde yer aliyor !!! "
sleep 1
errormsg
fi
}


stripe_pv_checks() {
# islem sirasinda tekrar disk device kontrol edilmesinde fayda var
disk=$(echo "$1"|sed 's/.*\///')
dskchk "$disk"
devdisk="/dev/$disk"

pvccheck
if [ -z "$pvc" ] ; then
echo "[$disk] [PV] diski olarak gorunmuyor .. [OK] "

else
## PV disk olup olmamasinin bir onemi yok..
echo "[$disk] zaten bir [PV] diski olarak gorunuyor .. [INFO] "

## Disk Aktif bir [VG] icinde yer aliyor mu ?
vgxstripeval=$(pvdisplay "$devdisk"|awk '/VG Name/{print $3}')
if [[ -z "$vgxstripeval" ]] ; then 
echo "[$disk] aktif bir [VG] icinde yer almiyor ... [OK] "
else

## Farkli bir [VG] icinde yer aliyor mu ?
vgx_stripe=$(pvdisplay "$devdisk"|awk '/VG Name/{if($3!=a)print $3}')
if [[ ! -z "$vgx_stripe" ]] ; then
echo "[$disk] zaten [$vgx_stripe] isimli [VG] icinde gorunuyor !! "
echo "[$disk] diskini [$vgx_stripe] isimli [VG] den cikarip (vgreduce/vgremove) islemi tekrar denemeniz gerekiyor !! "
sleep 1
errormsg
#echo "[$disk] [$vgx] isimli [VG] icinde gorunmuyor !!! "
#[[ "$lastp" == "ext" ]] && errormsg
fi
fi
fi
printit 30
echo
}


pv_other_layout() {
####
stripe_no=0
####
echo
case "$pvlayout" in
linear)echo "[$disk] diski uzerinde [$pvlayout] yapida [$vgx_layout] isminde [VG] bulundu .. "
echo
sleep 1
[[ "$lastp" == "ext" ]] && echo "Extend islemlerine devam edilecektir ... "
stripe_no=1
;;
mirror)echo "[$disk] diski uzerinde [$pvlayout] yapida [$vgx_layout] isminde [VG] bulundu .. "
echo
sleep 1
echo "Mirror [LVM] disk islemleri desteklenmemektedir !! " && errormsg
stripe_no=1
;;
raid*)echo "[$disk] diski uzerinde [$pvlayout] yapida [$vgx_layout] isminde [VG] bulundu .. "
echo
sleep 1
echo "Raid [LVM] disk islemleri desteklenmemektedir !! " && errormsg
stripe_no=1
;;
striped)echo "[$disk] diski uzerinde [$pvlayout] yapida [$vgx_layout] isminde [VG] bulundu .. "
echo
sleep 1
[[ "$lastp" == "ext" ]] && echo "[$disk] diski zaten bir [VG] icinde yer aldigi icin islemlere devam edilemiyor !! " && errormsg
stripe_no=0
;;
### unknown ###
#[root@xxxx ~]# pvs -o+lv_layout,stripes /dev/sde
#  PV         VG Fmt  Attr PSize PFree Layout     #Str
#  /dev/sde      lvm2 ---  4.00g 4.00g unknown       0
unknown)
printit 30
echo "[$disk] diski uzerindeki [PV] layout *[${pvlayout}] yapida gorunuyor .. "
sleep 1
[[ "$vgx_layout" == "unknown" ]] && echo "[$disk] [PV] diski icin bir [VG]/[LV] olusturmaniz gerekiyor olabilir !! "
#echo "[$disk] diski uzerindeki [PV] *[${pvlayout}] icinde aktif herhangi bir [VG] bulunamadi "
[[ ! -z "$vgx_layout" ]] &&  echo "[$disk] diski uzerindeki [$vgx_layout] [VG] icinde FREE alan olabilir [INFO] "
[[ -z "$vgx_layout" ]] && echo "[$disk] diski uzerinde aktif bir [VG] bilgisi bulunamadi [INFO] "
printit 30
echo
sleep 1
printit 30
pvs "$disk_layout_dev" -o+lv_layout,stripes 2>/dev/null
printit 30
sleep 1
;;
"")
echo
echo "[$disk] diski uzerinde [$vgx] isminde gecerli bir [VG] bilgisi bulunamadi .. !! "
vgs_chk=$(vgs "$vgx_layout" 2>/dev/null)
if [[ ! -z "$vgs_chk" ]] ; then
vglayout=$(vgs "$vgx_layout" -o+lv_layout,stripes|awk 'NR>1{print $(NF-1);exit}')
if [[ ! -z "$vglayout" ]] ; then
[[ "$vglayout" == "striped" ]] && stripe_no=1
echo "[$vgx_layout] [VG-$vglayout] yapida aktif olarak kullaniliyor !! "
sleep 1
fi
fi

if [[ "$lastp" = "new" ]] ; then
echo "-> [new] parametresi kullanilarak [VG] create yada extend islemleri yapilacaktir .. "
elif [[ "$lastp" = "ext" ]] ; then
echo "-> [ext] parametresi kullanilarak [VG] extend islemleri yapilacaktir .. "
fi
echo
sleep 1
#errormsg
#firstcheck "$1"
;;
*)
### unknown ###
#[root@xxxx ~]# pvs -o+lv_layout,stripes /dev/sde
#  PV         VG Fmt  Attr PSize PFree Layout     #Str
#  /dev/sde      lvm2 ---  4.00g 4.00g unknown       0
### failed ###
#[root@xxxx ~]# pvs -o+lv_layout,stripes /dev/sde
#  Failed to find physical volume "/dev/sde".
echo
echo "[$vgx] isminde gecerli bir [VG] bilgisi bulunamadi .. !! "
if [[ "$lastp" = "new" ]] ; then
echo "-> [new] parametresi kullanilarak yeni bir [VG] olusturulacaktir ... "
#firstcheck "$1"
sleep 1
elif [[ "$lastp" = "ext" ]] ; then
echo "[VG] layout bilgisi tespit edilemedi !!! "
sleep 1
errormsg
fi
echo

;;
esac
printit 40
echo
}


#### STRIPE SET ###
stripe_ext() {
printit 20
echo "-> [VG] Disk Layout [striped] olarak tespit edildi .. "
echo
sleep 2

[[ -z "$lvx" ]] && echo "LV bilgisi otomatik bulunacak .. " && lvnamecreate "$vgx" "ext"

#echo "Uygulama icinde sadece Disk Extend islemleri desteklenmektedir !!! "
sleep 1
printit 30
echo "Stripe yapida [LV] disk olusturmak icin ornek komut : "
printit 30
echo "-> [pvcreate /dev/sda1 /dev/sdb1 /dev/sdc1 ]
-> [vgcreate vgdata /dev/sda1 /dev/sdb1 /dev/sdc1]
-> [lvcreate -l 100%FREE -i4 -I128 -n lvdata vgdata]
-> [mkfs.xfs /dev/mapper/vgdata-lvdata] "
printit 30
echo
sleep 1

##########
#disks=1
#diskc=$pvsc
#vgstripe=$((diskc+1))
#lvstripe=$((diskc+2))


#until [ $diskc -lt 1 ] ; do
#eval v=\${$disks}
#v=$(echo "$v"|sed 's;/dev/;;')
#[[ -z "${stripedisks[@]}" ]] && stripedisks="$v" || stripedisks=(${stripedisks[@]} $v)
#((diskc--))
#((disks++))
#done

#v=$(echo "$v"|sed 's;/dev/;;')
#[[ -z "${stripedisks[@]}" ]] && stripedisks="$v" || stripedisks=(${stripedisks[@]} $v)

#if [[ $pvsc -ne ${#stripedisks[@]} ]] ; then
#echo
#echo "-> Toplamda [$pvsc] adet gecerli disk bilgisi girilmis olmalidir ... !! [FAIL] "
#errormsg
#fi



#eval v=\${$lvstripe}
#lvx="$v"
#lvcheck "$lvx" "ext"

devmapperchk;

echo "-> [striped] yapida [VG] extend islemleri icin kullanilacak diskler : [ ${stripedisks[@]} ] "
echo
printit 30
sleep 1

echo "[striped] Disk Extend islemlerine geciliyor .... "
sleep 3
printit 30

if [[ -z "${stripedisks[@]}" ]] ; then
echo "Disk bilgisi olusturulmasi isleminde HATA alindi !! "
errormsg
else
echo "[$vgx] [VG-striped ] icin extend islemleri uygulanacaktir .. "
echo
echo "[striped] [VG] device extend islemleri icin [ ${stripedisks[@]} ] bilgileri bir disk bilgisi olarak kullanilacaktir ... "
sleep 2
fi


##LV striped new segment extend
echo
echo "->> Toplamda [$pvsc] adet gecerli disk bilgisi girilmis olmalidir ... !!! "
sleep 2


for pvdskdev in ${stripedisks[@]}; do
echo
printit 40
echo "[$pvdskdev] diski kontrol ediliyor ... "
printit 40
stripecheck "$pvdskdev"
printit 40
done


for pvdskdev in ${stripedisks[@]}; do
stripe_pv_checks "$pvdskdev"
done


for pvdskdev in ${stripedisks[@]}; do
stripe_pv_checks "$pvdskdev"
pvcreatex 
#### striped VG extend ####
vgextendx "$vgx" "$devdisk" && errchk $? "vgextend"
done


#### striped LV extend ####
lvextendx "ext" "striped"
#lvextend --extents +100%FREE "$lvmmapperdev" && errchk $? "lvextend-striped"
sleep 2


###islem sonrasi filesystem islemleri
fschk "$lvmmapperdev" "ext" && [ "$fst" != "NULL" ] && resizepck "$fst" && resizefsx

}


stripe_arraycheck() {
local e match="$1"
shift
for e; do [[ "$e" == "$match" ]] && echo "[$e] diski parametre listesinde zaten belirtilmis !! " && echo && return 0; done
return 1
}


stripedisks_create() {
cc=$#

## VG striped
vgx_striped=${@: $((cc-3)):1}
lvx_striped=${@: $((cc-2)):1}

vgx="$vgx_striped"
lvx="$lvx_striped"

#vgx_stripe_dsktmp=$(echo ${@: $((cc-3)):1}|sed 's;/dev/;;')
vgx_tmp=$(echo "$vgx"|sed 's;/dev/;;')
if [ -b "/dev/$vgx_tmp" ] ; then
vgx="$lvx_striped"
lvx=""
printit 30
echo "-> [LV] bilgisi otomatik olusturulacak .. "
printit 30
sleep 1
fi


[[ -z "$lvx" ]] && stc=$((cc-2)) || stc=$((cc-3))
for((i=1;i<$stc;i++));do
v=$(echo "${@: $i:1}"|sed 's;/dev/;;')
if [[ -b "/dev/$v" ]] ; then
if [[ -z "${stripedisks[@]}" ]] ; then
stripedisks="$v"
else
stripe_arraycheck "$v" "${stripedisks[@]}"
[[ $? -eq 1 ]] && stripedisks=(${stripedisks[@]} $v)
fi
else
echo "-> [$v] parametresi gecerli bir disk device olarak gorunmuyor [FAIL] !! "
errormsg
fi
done
stripe_pvsc=${#stripedisks[@]}
}


stripe_layout() {
stripe_pv_dev="/dev/$1"
pvlayout=$(pvs -o+lv_layout,stripes|awk -v a="$stripe_pv_dev" 'a==$1{print $(NF-1);exit}')
}


stripe_vg_search() {
#son 4 parametrede VG stripe bilgisi aranir..
#vgxstripesrch=( ${@: -2:1} ${@: -3:1} ${@: -4:1} ${@: -5:1} )


striped_ext=0

vgx_chars=$(echo "$vgx" |grep -o .|grep -v -e '[a-z]' -e '[A-Z]' -e '[0-9]' -e '[-_+]' -e '\.')
if [[ ! -z "$vgx_chars" ]] ; then
echo "Girilen VG bilgisi [$vgx] gecersiz karakterler iceriyor gibi gorunuyor ->> " [ $vgx_chars ]
sleep 1
errormsg
fi

vg_tmp_x=$(vgs "$vgx" -o+lv_layout,stripes 2>/dev/null)
if [[ -z "$vg_tmp_x" ]] ; then
if [[ "$lastp" = "ext" ]] ; then
echo "[$vgx] isminde bir [VG] bulunamadi !! "
echo "[striped] [VG] islemleri icin gecerli bir [VG] bilgisi girilmelidir !!! "
sleep 1
errormsg
fi
else
echo "$vg_tmp_x"
printit 30
pvs -v --segments 2>/dev/null|awk -v a="$vgx" 'NR==1{print;next}$2==a'
fi

################
case "$lastp" in
ext)
vglayout=$(vgs "$vgx" -o+lv_layout|awk 'NR>1{print $NF;exit}')
if [[ "$vglayout" != "striped" ]] ; then
echo "[vgx] VG bilgisi [striped] layout yapida gorunmuyor !! "
sleep 1
[[ ! -z "$vglayout" ]] && echo "[VG-$vglayout]"
errormsg
fi

## VG-striped stripe sayisi
pvsc=$(lvs -o+lv_layout,stripes|awk -v a="$vgx" 'a==$2{print $NF;exit}')

if [[ $pvsc -ne $stripe_pvsc ]] ; then
echo
echo "-> [$vgx] icindeki stripe disk sayisi [$pvsc] ile girilen toplam disk sayisi [$stripe_pvsc] esit olmalidir ... !! [FAIL] "
errormsg
fi


###
for pvdskdev in ${stripedisks[@]}; do
stripe_layout "$pvdskdev"
pvlayout_unknown=0
if [[ "$pvlayout" == "unknown" ]] ; then
pv_stripe_vgx=$(pvdisplay "$pvdskdev" 2>/dev/null|awk '/VG Name/{print $3}')
if [ ! -z "$pv_stripe_vgx" ] ; then
echo "[$pvdskdev] diski uzerinde [$pv_stripe_vgx] isminde tanimli bir [VG] bulunuyor !! "
[[ "$vglayout" != "$pv_stripe_vgx" ]] && errormsg
else
pvlayout_unknown=1
fi
fi

if [[ -z "$pvlayout" ]] ; then
striped_ext=1
sleep 1
else
echo
if [[ $pvlayout_unknown -eq 0 ]] ; then
echo "[$pvdskdev] disk layout bilgisi [$pvlayout] olarak bulunmustur .. "
echo "[$pvdskdev] diski zaten [$vgx] {VG] icinde yer almaktadir !! [FAIL] "
errormsg
fi
#break
fi

done
;;


new)
if [[ $stripe_pvsc -lt 2 ]] ; then
[[ "$lastp" == "new" ]] && echo "[striped] yapida bir [VG] olusturulmasi icin en az x2 disk gereklidir [FAIL] " && echo " Mevcut disk sayisi -> $stripe_pvsc "
errormsg
fi

for pvdskdev in ${stripedisks[@]}; do
stripe_layout "$pvdskdev"

if [[ "$pvlayout" == "unknown" ]] ; then
pv_stripe_vgx=$(pvdisplay "$pvdskdev" 2>/dev/null|awk '/VG Name/{print $3}')
if [ ! -z "$pv_stripe_vgx" ] ; then
echo "[$pvdskdev] diski uzerinde [$pv_stripe_vgx] isminde tanimli bir [VG] bulunuyor !! "
errormsg
fi
fi

done

esac
}


stripe_new() {
##########
#striped_full="$@"
#son 4 parametre -> [vgx lvx striped new]
#son 4 parametre -> [sdx vgx striped new]
#disks="${@: -4}"
#diskt="${#@}"
#ilk parametre disk mi VG mi ?
#set -- ${disks[@]}

[[ -z "$lvx" ]] && lvnamecreate "$vgx" "new"
[[ -z "$lvx" ]] && echo "Stripe [LV] bilgisi olusturulamadi !! " && errormsg
#diskstrpc=$(($diskt-3))

##stripedisks new
#for((i=1;i<=$diskstrpc;i++)); do
#eval v=\${$i}
#[[ -z "${stripedisks[@]}" ]] && stripedisks="$v" || stripedisks=(${stripedisks[@]} $v)
#done

printit 30
echo
echo "-> [striped] yapida [VG] olusturabilmek icin kullanilacak diskler : [ ${stripedisks[@]} ] "
echo
printit 30
sleep 1


##PV check
for pvdskdev in ${stripedisks[@]}; do
stripe_pv_checks "$pvdskdev"
[[ -z "${stripe_devdisks[@]}" ]] && stripe_devdisks="/dev/${pvdskdev}" || stripe_devdisks=(${stripe_devdisks[@]} "/dev/${pvdskdev}")
done


##VG create
vgcreate "$vgx" ${stripe_devdisks[@]} ; errchk $? "vgcreate"

echo
printit 30
echo "->> Default STRIPE SIZE = 128 KB "
sleep 1
echo "->> Default STRIPE SIZE = 128 KB "
sleep 1
echo "->> Default STRIPE SIZE = 128 KB "
echo
printit 30
echo -e "[lvcreate] islemi kesmek icin 'Ctrl-C' tuslarini kullanabilirsiniz !! \n"
sleep 2

##
##LV create
Stripe_Size=128  ## 128KB
stripepvc=${#stripedisks[@]}
if [ -z "$size" ] ; then
lvcreate -l 100%FREE -i ${stripepvc} -I "${Stripe_Size}" -n $lvx $vgx ; errchk $? "lvcreate"
else
lvcreate -i ${stripepvc} -I "${Stripe_Size}" -L "${sizec}" -n $lvx $vgx ; errchk $? "lvcreate"
fi

## Stripe LV Create
devmapperchk;
####
fschk_p_wait=3
fschck_limit $fschk_p_wait

fschk_new "$fst"
fstchk "$fst"
formatx "$fst"

mountx
sleep 1
}


stripe_check() {
#sc="${#@}"
#shift $((sc-2))
##striped kelimesi aranir...
cc=$#
echo ${@: $((cc-1)):1}
}


last_param_check() {
#for last; do true; done
#echo "$last"
issize $@
[[ ! -z "$size" ]] && set -- "${@: 1: $#-1}"
lastp="${@: -1}"

## son parametre kontrolu
if [[ "$lastp" != "ext" ]] && [[ "$lastp" != "new" ]] ; then
if [[ "$#" -lt 2 ]] ; then
echo "En az 2 parametre ile islem yapilabilir !! "
else
echo "Bilinmeyen parametre [$lastp] degeri girildi !! "
fi
errormsg
fi
}


lv_layout_check() {
## son parametre kontrolu
last_param_check $@;

## Linear yapilarda sadece 1 tane disk ile islem yapilabilir .. ##
if [ ! -z "$1" ] ; then
firstcheck "$1"
#disk_layout=$(echo "$devdisk"|sed 's;/dev/;;')
[[ -z "$devdisk" ]] && echo "Disk device bulunamadi !! " && errormsg
[[ ! -z "$devdisk" ]] && disk_layout_dev="$devdisk"
#echo "$disk"|grep -e 'dm-' -e mapper -e mpath >/dev/null

###
echo "$devdisk"|grep -e '/dev/mapper/'|grep -v dm- >/dev/null
if [ $? -eq 0 ] ; then
case "$disk" in
*)
mpathx=$(ls -ltr /dev/mapper/|grep " $disk "|sed 's/.* \([^ ]*\) ->.*/\1/')
pvdiskchk="/dev/mapper/$mpathx"
;;
esac
fi


## multipath device
[[ ! -z "$pvdiskchk" ]] && disk_layout_dev="$pvdiskchk" || disk_layout_dev="$devdisk"

###
pvslc=$(pvs "${disk_layout_dev}" -o+lv_layout,stripes 2>/dev/null|awk 'END{if(NR)print NR-1;else print 0}')
if [ $pvslc -eq 0 ] ; then
[[ "$lastp" == "new" ]] && echo "[$disk] diskinin bir [PV] disk oldugundan emin olun [INFO] "
[[ "$lastp" == "ext" ]] && echo "[$disk] diskinin bir [PV] disk oldugundan emin olun [FAIL] "
sleep 1
elif [ $pvslc -eq 1 ] ; then
pvlayout=$(pvs "${disk_layout_dev}" -o+lv_layout,stripes|awk 'NR>1{print $(NF-1)}')
#vgx_layout=$(pvs "${disk_layout_dev}" -o+lv_layout,stripes|awk 'NR>1{a[$2]}END{for(i in a)print i}')
vgx_layout=$(pvdisplay "${disk_layout_dev}"|sed -n '/VG Name/s/  VG Name//p'|sed 's/ *//g')
elif [ $pvslc -gt 1 ] ; then
echo "-> [$disk_layout_dev] birden fazla segment iceriyor olabilir [INFO] "
printit 40
pvlayout=$(pvs "${disk_layout_dev}" -o+lv_layout,stripes|awk 'NR>1{a[$(NF-1)]++}END{for(i in a)print i}')
pvs "${disk_layout_dev}" -v --segments
vgx_layout=$(pvdisplay "${disk_layout_dev}"|sed -n '/VG Name/s/  VG Name//p'|sed 's/ *//g')
pvlayoutc=$(echo "$pvlayout"|awk 'END{print NR}')
if [ $pvlayoutc -gt 1 ] ; then
echo
echo "-> [$disk] diskinde birden fazla Layout bilgisi tespit edildi [WARN] "
echo "-> [$disk] diskinde henuz bir [LV] device atanmamis Free Alan olabilir [INFO] "
sleep 1
pvlayout=$(vgs "$vgx_layout" -o+lv_layout | awk 'NR>1{print $NF}')
fi
printit 50
pvs "${disk_layout_dev}" -o+lv_layout,stripes
printit 50
[[ "$pvlayout" = "unknown" ]] && echo "[$disk_layout_dev] disk alaninin tamami kullanilmamis olabilir !! "
fi

###
vg_empty=$(pvs "${disk_layout_dev}" -o+lv_layout,stripes|awk 'NR>1{if($2=="lvm2")print "OK"}')
if [[ ! -z "$vg_empty" ]] ; then
if [[ "$lastp" == "new" ]] ; then
echo "-> [$disk] diski herhangi bir [VG] dahil edilmemis [OK] "
echo
fi
sleep 1
fi
else
echo "1. parametre bos olamaz !! "
echo "Disk bilgisi bulunamiyor !! "
errormsg
fi

## Linear VG islemleri 1 tane disk bilgisi ile isletilebilir. Bu nedenle 2. parametre VG olmak zorundadir..
if [ ! -z "$2" ] ; then
vgx="$2"
vgsfchk=$(vgs "$vgx" 2>/dev/null)
if [[ -z "$vgsfchk" ]] ; then
if [[ "$lastp" == "ext" ]] ; then
[[ "$pvlayout" == "linear" ]] && echo "[$vgx] isminde Linear yapida aktif bir [VG] bulunamadi [FAIL] "
if [[ "$vgx" == "ext" ]] || [[ "$vgx" == "new" ]] ; then
echo "[VG] bilgisi olarak [$vgx] degeri kullanilamaz !! "
errormsg
fi
fi
fi

else
echo "2. parametre bos olamaz !! "
echo "[VG] bilgisi bulunamiyor !! "
errormsg
fi


####
pv_other_layout
####

#pvsc=$(lvs -o+lv_layout,stripes|awk -v a="$vgx" 'a==$2{print $NF;exit}')

##1. parametre disk bilgisi olmali !!
#firstcheck "$1"

## 2. parametre ile striped yapida bir [VG] ismi bulunamaz !!
##########################################################

## [VG] tespit edilemedi ise
## stripe kontrolleri ##
#echo "[$vgx] isminde gecerli bir [VG] bulunamadi !! "
## Layout Linear degil veya new islemleri ise
## son parametre size bilgisi iceriyor mu?


## stripe kontrolu
if [ "$stripe_no" -eq 0 ] ; then
echo "[striped] [PV] layout parametre kontrolleri yapiliyor ... "
printit 60
sleep 1

#####################################################
### HENUZ DESTEKLENMEYEN LVM LAYOUT BILGILERI !!! ###
## raid vg_search $@
## mirror vg_search $@
#####################################################
issize $@
[[ ! -z "$size" ]] && set -- "${@: 1: $#-1}"

stripe_param=0
## [striped] parametresi girilmesi zorunlu !!
is_stripe=$(stripe_check $@)
if [[ "$is_stripe" == "[s]triped" ]] ; then 
stripedisks_create $@
stripe_vg_search $@
stripe_param=1
fi

## layout (stripe/raid.. ) layout bilgisini belirle..
#pv_other_layout $@;


if [[ $stripe_param -eq 1 ]] ; then

for pvdskdev in ${stripedisks[@]}; do
firstcheck "$pvdskdev" "stripe"
done


## Stripe layout ext islemleri
if [[ $striped_ext -eq 1 ]] ; then
echo "[$vgx_striped] *[VG-striped] yapida [ x$stripe_pvsc ] konfigurasyonda olusturulmus gorunuyor ... "
sleep 1
if [[ "$lastp" == "ext" ]] ; then
echo "-> [striped] yapida [$vgx] icin [VG] extend islemleri gerceklestirilecektir ... "
sleep 2
vgx_striped=$vgx
[[ -z "$lvx" ]] && lvx_striped=$(lvs -o+lv_layout,stripes|awk -v a="$vgx_striped" 'a==$2{print $1;exit}') && lvx="$lvx_striped"
[[ -z "$lvx" ]] && echo "[$vgx] [striped] diske ait [LV] bilgisi bulunamiyor .. !! " && errormsg
if [[ ! -z "$lvx" ]] ; then
lvx_striped_tmp=$(lvs -o+lv_layout,stripes|awk -v a="$vgx_striped" 'a==$2{print $1;exit}')
if [[ "$lvx_striped_tmp" != "$lvx" ]] ; then
echo
echo "[$vgx] [VG] icinde [$lvx] isimli [LV] device bulunamiyor !! "
sleep 1
errormsg
fi
fi


stripe_ext $@;
elif [[ "$lastp" == "new" ]] ; then
echo "[$vgx_striped] isimli [VG] zaten [striped] yapida olusturulmus gorunuyor .. !! "
errormsg
fi
fi


## Stripe layout new islemleri
if [[ "$lastp" == "new" ]] ; then
printit 30
echo
echo "-> [striped] yapida yeni bir [VG] create islemleri gerceklestirilecektir ... "
sleep 2
## 'striped' isiminde bir LV bilgisi olusturulma ihtimaline karsilik 1 onceki parametrenin Disk Device olmamasi lazim !!
## Bunun yerine [linear] layout [VG] lar icin yeni bir VG ismi belirtilmis olmasi gerekiyor..
## [striped] layout VG icin Bu kontrol icin 'striped' kelimesinden bir onceki parametrenin disk degilde [VG-striped] olmasi gerekli .. !!
echo "[VG] bilgisi olarak [$vgx] kullanilacak !!! "
printit 30
if [[ ! -b "/dev/$vgx" ]] ; then
stripe_new $@;
fi
fi
else
echo "[striped] parametresi bulunamadi !! "
echo
#firstcheck "$1"
fi
fi
}


###yucel gemici 2023
lv_layout_check $@;
justdoit $@;
